package postgres

/**
	Auto-Generated by Mango SQL
	DO NOT EDIT!
	Project: https://github.com/kefniark/mangosql
	Date: 2024-07-29 10:53:08.629559707 +0000 UTC m=+0.021300677
**/

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"database/sql"
	squirrel "github.com/Masterminds/squirrel"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

type SelectBuilder = squirrel.SelectBuilder
type WhereCondition = func(query SelectBuilder) SelectBuilder

type DBClient struct {
	ctx *DBContext
	// Handle database's users records.
	// Create, Update, Delete or Query User Models with typed safe helpers
	//
	// Usage:
	//   user, err := db.User.FindById(id)
	User *UserQueries
	// Handle database's items records.
	// Create, Update, Delete or Query Item Models with typed safe helpers
	//
	// Usage:
	//   user, err := db.Item.FindById(id)
	Item *ItemQueries
	// Handle database's item_meta records.
	// Create, Update, Delete or Query ItemMeta Models with typed safe helpers
	//
	// Usage:
	//   user, err := db.ItemMeta.FindById(id)
	ItemMeta *ItemMetaQueries
	// User Custom SQL Queries
	//
	// Usage:
	//   entities, err := db.Queries.MySqlRequests()
	Queries *CustomQueries
}

func newClient(ctx *DBContext) *DBClient {
	return &DBClient{
		ctx:      ctx,
		User:     &UserQueries{ctx: ctx},
		Item:     &ItemQueries{ctx: ctx},
		ItemMeta: &ItemMetaQueries{ctx: ctx},
		Queries:  &CustomQueries{ctx: ctx}}
}

// Create a new instance of MangoSql
func New(db *sqlx.DB) *DBClient {
	return newClient(&DBContext{
		db:       db,
		prepared: make(map[string]*sqlx.Stmt),
		tx:       nil,
	})
}

// Create a new Sql transaction.
// If any error or panic occurs inside, the transaction is automatically rollback
//
// Usage:
//
//	err := db.Transaction(func(tx *DBClient) error {
//	  // ... can use tx. like db.
//	})
func (db DBClient) Transaction(transaction func(dbClient *DBClient) error) (e error) {
	if db.ctx.tx != nil {
		return fmt.Errorf("nested transaction is not supported")
	}

	tx, err := db.ctx.db.Beginx()
	if err != nil {
		return err
	}

	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			e = errors.New(p.(string))
		}
	}()

	client := newClient(&DBContext{
		db:       db.ctx.db,
		prepared: db.ctx.prepared,
		tx:       tx,
	})
	if err = transaction(client); err != nil {
		tx.Rollback()
		return err
	}

	return tx.Commit()
}

// Split slice into chunks of the given size
func chunkBy[T any](items []T, chunkSize int) (chunks [][]T) {
	for chunkSize < len(items) {
		items, chunks = items[chunkSize:], append(chunks, items[0:chunkSize:chunkSize])
	}
	return append(chunks, items)
}

// Execute a Custom SQL query and get one row result.
//
// Usage:
//
//	res := MyResult{}
//	err := db.RawQueryOne(&res, sql, args...)
func (db *DBClient) RawQueryOne(data interface{}, sql string, args ...interface{}) error {
	return db.ctx.queryOne(data, sql, args...)
}

// Execute a Custom SQL query and get many rows result.
//
// Usage:
//
//	res := []MyResult{}
//	err := db.RawQueryMany(&res, sql, args...)
func (db *DBClient) RawQueryMany(data interface{}, sql string, args ...interface{}) error {
	return db.ctx.queryMany(data, sql, args...)
}

// Execute a Custom SQL query without result.
//
// Usage:
//
//	err := db.RawExec(sql, args...)
func (db *DBClient) RawExec(sql string, args ...interface{}) error {
	return db.ctx.exec(sql, args...)
}

func (ctx *DBContext) queryOne(data interface{}, sql string, args ...interface{}) error {
	stmt, err := ctx.stmt(sql)
	if err != nil {
		return err
	}

	return stmt.Get(data, args...)
}

func (ctx *DBContext) queryMany(data interface{}, sql string, args ...interface{}) error {
	stmt, err := ctx.stmt(sql)
	if err != nil {
		return err
	}

	return stmt.Select(data, args...)
}

func (ctx *DBContext) exec(sql string, args ...interface{}) error {
	stmt, err := ctx.stmt(sql)
	if err != nil {
		return err
	}

	_, err = stmt.Exec(args...)
	return err
}

func (ctx *DBContext) stmt(query string) (*sqlx.Stmt, error) {
	if _, ok := ctx.prepared[query]; !ok {
		stmt, err := ctx.db.Preparex(query)
		if err != nil {
			return nil, err
		}
		ctx.prepared[query] = stmt
	}

	stmt := ctx.prepared[query]
	if ctx.tx != nil {
		return ctx.tx.Stmtx(stmt), nil
	}
	return stmt, nil
}

func first[T any](items []T, err error) (*T, error) {
	if err != nil {
		return nil, err
	}

	if len(items) == 0 {
		return nil, fmt.Errorf("not found")
	}

	return &items[0], nil
}

func limitFirst(cond SelectBuilder) SelectBuilder {
	return cond.Offset(0).Limit(1)
}

const (
	// users table
	userTable         = `users`
	userCreateSql     = `INSERT INTO users (id, email, name) VALUES ($1, $2, $3) RETURNING id, email, name, created_at, updated_at, deleted_at`
	userCreateManySql = `INSERT INTO users (id, email, name) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, email VARCHAR(64), name VARCHAR(64)) RETURNING users.id`
	userUpsertSql     = `INSERT INTO users (id, email, name) VALUES ($1, $2, $3) ON CONFLICT(id) DO UPDATE SET email=EXCLUDED.email, name=EXCLUDED.name, updated_at=NOW() RETURNING id, email, name, created_at, updated_at, deleted_at`
	userUpsertManySql = `INSERT INTO users (id, email, name) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, email VARCHAR(64), name VARCHAR(64)) ON CONFLICT(id) DO UPDATE SET email=EXCLUDED.email, name=EXCLUDED.name RETURNING users.id`
	userUpdateSql     = `UPDATE users SET email=$2, name=$3, updated_at=NOW() WHERE id=$1 RETURNING id, email, name, created_at, updated_at, deleted_at`
	userUpdateManySql = `UPDATE users SET email=t.email, name=t.name FROM jsonb_to_recordset($1) as t(id UUID, email VARCHAR(64), name VARCHAR(64)) WHERE users.id=t.id RETURNING users.id`
	userDeleteSoftSql = `UPDATE users SET deleted_at=NOW() WHERE id=$1`
	userDeleteHardSql = `DELETE FROM users WHERE id=$1`
	// items table
	itemTable         = `items`
	itemCreateSql     = `INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) VALUES ($1, $2, $3, $4, NOW(), NOW()) RETURNING id, name, quantity, user_id, created_at, updated_at, deleted_at`
	itemCreateManySql = `INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) SELECT *, NOW(), NOW() FROM jsonb_to_recordset($1) as t(id UUID, name TEXT, quantity INT8, user_id UUID) RETURNING items.id`
	itemUpsertSql     = `INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) VALUES ($1, $2, $3, $4, NOW(), NOW()) ON CONFLICT(id) DO UPDATE SET name=EXCLUDED.name, quantity=EXCLUDED.quantity, user_id=EXCLUDED.user_id, updated_at=NOW() RETURNING id, name, quantity, user_id, created_at, updated_at, deleted_at`
	itemUpsertManySql = `INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) SELECT *, NOW(), NOW() FROM jsonb_to_recordset($1) as t(id UUID, name TEXT, quantity INT8, user_id UUID) ON CONFLICT(id) DO UPDATE SET name=EXCLUDED.name, quantity=EXCLUDED.quantity, user_id=EXCLUDED.user_id RETURNING items.id`
	itemUpdateSql     = `UPDATE items SET name=$2, quantity=$3, user_id=$4, updated_at=NOW() WHERE id=$1 RETURNING id, name, quantity, user_id, created_at, updated_at, deleted_at`
	itemUpdateManySql = `UPDATE items SET name=t.name, quantity=t.quantity, user_id=t.user_id FROM jsonb_to_recordset($1) as t(id UUID, name TEXT, quantity INT8, user_id UUID) WHERE items.id=t.id RETURNING items.id`
	itemDeleteSoftSql = `UPDATE items SET deleted_at=NOW() WHERE id=$1`
	itemDeleteHardSql = `DELETE FROM items WHERE id=$1`
	// item_meta table
	itemMetaTable         = `item_meta`
	itemMetaCreateSql     = `INSERT INTO item_meta (id, key, value, item_id) VALUES ($1, $2, $3, $4) RETURNING id, key, value, item_id`
	itemMetaCreateManySql = `INSERT INTO item_meta (id, key, value, item_id) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, key TEXT, value TEXT, item_id UUID) RETURNING item_meta.id`
	itemMetaUpsertSql     = `INSERT INTO item_meta (id, key, value, item_id) VALUES ($1, $2, $3, $4) ON CONFLICT(id) DO UPDATE SET key=EXCLUDED.key, value=EXCLUDED.value, item_id=EXCLUDED.item_id RETURNING id, key, value, item_id`
	itemMetaUpsertManySql = `INSERT INTO item_meta (id, key, value, item_id) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, key TEXT, value TEXT, item_id UUID) ON CONFLICT(id) DO UPDATE SET key=EXCLUDED.key, value=EXCLUDED.value, item_id=EXCLUDED.item_id RETURNING item_meta.id`
	itemMetaUpdateSql     = `UPDATE item_meta SET key=$2, value=$3, item_id=$4 WHERE id=$1 RETURNING id, key, value, item_id`
	itemMetaUpdateManySql = `UPDATE item_meta SET key=t.key, value=t.value, item_id=t.item_id FROM jsonb_to_recordset($1) as t(id UUID, key TEXT, value TEXT, item_id UUID) WHERE item_meta.id=t.id RETURNING item_meta.id`
	itemMetaDeleteHardSql = `DELETE FROM item_meta WHERE id=$1`
)

type DBContext struct {
	db       *sqlx.DB
	tx       *sqlx.Tx
	prepared map[string]*sqlx.Stmt
}

// Table users

var UserFields = []string{"id", "email", "name", "created_at", "updated_at", "deleted_at"}

type UserPrimaryKey = uuid.UUID

type UserModel struct {
	Id        uuid.UUID    `json:"id" db:"id"`
	Email     string       `json:"email" db:"email"`
	Name      string       `json:"name" db:"name"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt time.Time    `json:"updated_at" db:"updated_at"`
	DeletedAt sql.NullTime `json:"deleted_at" db:"deleted_at"`
}

type UserCreate struct {
	Email string `json:"email" db:"email"`
	Name  string `json:"name" db:"name"`
}

type UserUpdate struct {
	Id    uuid.UUID `json:"id" db:"id"`
	Email string    `json:"email" db:"email"`
	Name  string    `json:"name" db:"name"`
}

type UserQueries struct {
	ctx *DBContext
	// Used to modify User queries (filter, pagination, search, ...)
	//
	// Usage:
	//   users, err := db.User.FindMany(
	//     db.User.Query.DeletedAt.IsNotNull(),
	//     db.User.Query.Name.OrderAsc(),
	//     # add more conditions ...
	//   )
	Query UserFilters
}

type UserFilters struct {
	Id        UserIdFilters
	Email     UserEmailFilters
	Name      UserNameFilters
	CreatedAt UserCreatedAtFilters
	UpdatedAt UserUpdatedAtFilters
	DeletedAt UserDeletedAtFilters
}

type UserIdFilters struct{}
type UserEmailFilters struct{}
type UserNameFilters struct{}
type UserCreatedAtFilters struct{}
type UserUpdatedAtFilters struct{}
type UserDeletedAtFilters struct{}

// Create a new UserModel instance (not automatically saved in database)
//
// Example :
//
//	users = db.User.New()
//	users.Name = "newName"
//	// ... manipulate the users entity
//	err = users.Save(db)
func (q *UserQueries) New() *UserModel {
	return &UserModel{
		Id: uuid.New(),
	}
}

// Save a UserModel
//
// Usage:
//
//	user, err = db.User.FindById(id)
//	user.Name = "newName"
//	err = user.Save(db)
func (q *UserModel) Save(db *DBClient) error {
	data, err := db.User.Upsert(UserUpdate{
		Id:    q.Id,
		Email: q.Email,
		Name:  q.Name,
	})
	*q = *data
	return err
}

// Insert a User and return the created row
//
// Usage:
//
//	entity, err := db.User.Insert(UserCreate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO users (id, email, name) VALUES ($1, $2, $3) RETURNING id, email, name, created_at, updated_at, deleted_at
func (q *UserQueries) Insert(input UserCreate) (*UserModel, error) {
	data := &UserModel{}
	if err := q.ctx.queryOne(data, userCreateSql, uuid.New(), input.Email, input.Name); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Insert User
//
// Usage:
//
//	entities, err := db.User.InsertMany([]UserCreate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO users (id, email, name) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, email VARCHAR(64), name VARCHAR(64)) RETURNING users.id
func (q *UserQueries) InsertMany(inputs []UserCreate) ([]UserPrimaryKey, error) {
	ids := []UserPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		records := make([]UserUpdate, len(chunk))
		for i, input := range chunk {
			records[i] = UserUpdate{
				Id:    uuid.New(),
				Email: input.Email,
				Name:  input.Name,
			}
		}

		data, err := json.Marshal(records)
		if err != nil {
			return nil, err
		}

		loopIds := []UserPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, userCreateManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Upsert a User (create or update if already exist) and return the updated row
//
// Usage:
//
//	entity, err := db.User.Upsert(UserUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO users (id, email, name) VALUES ($1, $2, $3) ON CONFLICT(id) DO UPDATE SET email=EXCLUDED.email, name=EXCLUDED.name, updated_at=NOW() RETURNING id, email, name, created_at, updated_at, deleted_at
func (q *UserQueries) Upsert(input UserUpdate) (*UserModel, error) {
	data := &UserModel{}
	if err := q.ctx.queryOne(data, userUpsertSql, input.Id, input.Email, input.Name); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Upsert User (create or update if already exist)
//
// Usage:
//
//	entities, err := db.User.UpsertMany([]UserUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO users (id, email, name) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, email VARCHAR(64), name VARCHAR(64)) ON CONFLICT(id) DO UPDATE SET email=EXCLUDED.email, name=EXCLUDED.name RETURNING users.id
func (q *UserQueries) UpsertMany(inputs []UserUpdate) ([]UserPrimaryKey, error) {
	ids := []UserPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []UserPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, userUpsertManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Update a User and return the updated row
//
// Usage:
//
//	entity, err := db.User.Update(UserUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	UPDATE users SET email=$2, name=$3, updated_at=NOW() WHERE id=$1 RETURNING id, email, name, created_at, updated_at, deleted_at
func (q *UserQueries) Update(input UserUpdate) (*UserModel, error) {
	data := &UserModel{}
	if err := q.ctx.queryOne(data, userUpdateSql, input.Id, input.Email, input.Name); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Update User
//
// Usage:
//
//	entities, err := db.User.UpdateMany([]UserUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	UPDATE users SET email=t.email, name=t.name FROM jsonb_to_recordset($1) as t(id UUID, email VARCHAR(64), name VARCHAR(64)) WHERE users.id=t.id RETURNING users.id
func (q *UserQueries) UpdateMany(inputs []UserUpdate) ([]UserPrimaryKey, error) {
	ids := []UserPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []UserPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, userUpdateManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Delete a User (soft delete, data are still in the database)
//
// Usage:
//
//	err := db.User.DeleteSoft(id)
//
// SQL Statement:
//
//	UPDATE users SET deleted_at=NOW() WHERE id=$1
func (q *UserQueries) DeleteSoft(id UserPrimaryKey) error {
	return q.ctx.exec(userDeleteSoftSql, id)
}

// Delete a User (soft delete, data are still in the database)
func (q *UserModel) DeleteSoft(db *DBClient) error {
	return db.User.DeleteSoft(q.Id)
}

// Delete a User (hard delete, data are removed from the database)
//
// Usage:
//
//	err := db.User.DeleteHard(id)
//
// SQL Statement:
//
//	DELETE FROM users WHERE id=$1
func (q *UserQueries) DeleteHard(id UserPrimaryKey) error {
	return q.ctx.exec(userDeleteHardSql, id)
}

// Delete a User (hard delete, data are removed from the database)
func (q *UserModel) DeleteHard(db *DBClient) error {
	return db.User.DeleteHard(q.Id)
}

// Count User records based on filter conditions
//
// Usage:
//
//	count, err := db.User.Count(
//	  // ... can use filters here (cf db.User.Query.*)
//	)
func (q *UserQueries) Count(filters ...WhereCondition) (int, error) {
	query := squirrel.Select("count(id)").From(userTable).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = q.ctx.queryOne(&count, sql, args...)
	return count, err
}

// Find User records based on the provided conditions
//
// Usage:
//
//	entities, err := db.User.FindMany(
//	  // ... can use filters here (cf db.User.Query.*)
//	)
func (q *UserQueries) FindMany(filters ...WhereCondition) ([]UserModel, error) {
	query := squirrel.Select(UserFields...).From(userTable).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []UserModel{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

// Find one User records based on the provided conditions
//
// Usage:
//
//	entity, err := db.User.FindUnique(
//	  // ... can use filters here (cf db.User.Query.*)
//	)
func (q *UserQueries) FindUnique(filters ...WhereCondition) (*UserModel, error) {
	filters = append(filters, limitFirst)
	return first(q.FindMany(filters...))
}

// Find User By PrimaryKey
//
// Usage:
//
//	entity, err := db.User.FindById(id)
func (q *UserQueries) FindById(id UserPrimaryKey) (*UserModel, error) {
	return q.FindUnique(func(cond SelectBuilder) SelectBuilder {
		return cond.Where("id = $1", id)
	})
}

// Batch Find User By PrimaryKey
//
// Usage:
//
//	entities, err := db.User.FindByIds(ids)
func (q *UserQueries) FindByIds(ids ...UserPrimaryKey) ([]UserModel, error) {
	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
		return cond.Where("id = ANY($1)", pq.Array(ids))
	})
}

// Filter to only include User with a specific Id value
func (UserIdFilters) Equal(arg uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.id = $1", arg)
	}
}

// Filter to exclude User with a specific Id value
func (UserIdFilters) NotEqual(arg uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.id != $1", arg)
	}
}

// Filter to only include User with a specific Id value
func (UserIdFilters) In(args ...uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.id = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude User with a specific Id value
func (UserIdFilters) NotIn(args ...uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(users.id = ANY($1))", pq.Array(args))
	}
}

// Filter to sort User by Id is ASC order
func (UserIdFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.id DESC")
	}
}

// Filter to sort User by Id is DESC order
func (UserIdFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.id DESC")
	}
}

// Filter to only include User with a specific Email value
func (UserEmailFilters) Equal(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.email = $1", arg)
	}
}

// Filter to exclude User with a specific Email value
func (UserEmailFilters) NotEqual(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.email != $1", arg)
	}
}

// Filter to only include User with a specific Email value
func (UserEmailFilters) In(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.email = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude User with a specific Email value
func (UserEmailFilters) NotIn(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(users.email = ANY($1))", pq.Array(args))
	}
}

// Filter to only include User when Email is LIKE $value
func (UserEmailFilters) Like(search string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.email ILIKE $1", search)
	}
}

// Filter to sort User by Email is ASC order
func (UserEmailFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.email DESC")
	}
}

// Filter to sort User by Email is DESC order
func (UserEmailFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.email DESC")
	}
}

// Filter to only include User with a specific Name value
func (UserNameFilters) Equal(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.name = $1", arg)
	}
}

// Filter to exclude User with a specific Name value
func (UserNameFilters) NotEqual(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.name != $1", arg)
	}
}

// Filter to only include User with a specific Name value
func (UserNameFilters) In(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.name = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude User with a specific Name value
func (UserNameFilters) NotIn(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(users.name = ANY($1))", pq.Array(args))
	}
}

// Filter to only include User when Name is LIKE $value
func (UserNameFilters) Like(search string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.name ILIKE $1", search)
	}
}

// Filter to sort User by Name is ASC order
func (UserNameFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.name DESC")
	}
}

// Filter to sort User by Name is DESC order
func (UserNameFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.name DESC")
	}
}

// Filter to only include User with a specific CreatedAt value
func (UserCreatedAtFilters) Equal(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.created_at = $1", arg)
	}
}

// Filter to exclude User with a specific CreatedAt value
func (UserCreatedAtFilters) NotEqual(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.created_at != $1", arg)
	}
}

// Filter to only include User with a specific CreatedAt value
func (UserCreatedAtFilters) In(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.created_at = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude User with a specific CreatedAt value
func (UserCreatedAtFilters) NotIn(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(users.created_at = ANY($1))", pq.Array(args))
	}
}

// Filter to only include User when CreatedAt happen after $value
func (UserCreatedAtFilters) After(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.created_at > $1", val)
	}
}

// Filter to only include User when CreatedAt happen before $value
func (UserCreatedAtFilters) Before(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.created_at < $1", val)
	}
}

// Filter to only include User when CreatedAt happen between $low and $high
func (UserCreatedAtFilters) Between(low time.Time, high time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.created_at BETWEEN $1 AND $2", low, high)
	}
}

// Filter to sort User by CreatedAt is ASC order
func (UserCreatedAtFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.created_at DESC")
	}
}

// Filter to sort User by CreatedAt is DESC order
func (UserCreatedAtFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.created_at DESC")
	}
}

// Filter to only include User with a specific UpdatedAt value
func (UserUpdatedAtFilters) Equal(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.updated_at = $1", arg)
	}
}

// Filter to exclude User with a specific UpdatedAt value
func (UserUpdatedAtFilters) NotEqual(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.updated_at != $1", arg)
	}
}

// Filter to only include User with a specific UpdatedAt value
func (UserUpdatedAtFilters) In(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.updated_at = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude User with a specific UpdatedAt value
func (UserUpdatedAtFilters) NotIn(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(users.updated_at = ANY($1))", pq.Array(args))
	}
}

// Filter to only include User when UpdatedAt happen after $value
func (UserUpdatedAtFilters) After(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.updated_at > $1", val)
	}
}

// Filter to only include User when UpdatedAt happen before $value
func (UserUpdatedAtFilters) Before(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.updated_at < $1", val)
	}
}

// Filter to only include User when UpdatedAt happen between $low and $high
func (UserUpdatedAtFilters) Between(low time.Time, high time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.updated_at BETWEEN $1 AND $2", low, high)
	}
}

// Filter to sort User by UpdatedAt is ASC order
func (UserUpdatedAtFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.updated_at DESC")
	}
}

// Filter to sort User by UpdatedAt is DESC order
func (UserUpdatedAtFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.updated_at DESC")
	}
}

// Filter to only include User with a specific DeletedAt value
func (UserDeletedAtFilters) Equal(arg sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at = $1", arg)
	}
}

// Filter to exclude User with a specific DeletedAt value
func (UserDeletedAtFilters) NotEqual(arg sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at != $1", arg)
	}
}

// Filter to only include User with a specific DeletedAt value
func (UserDeletedAtFilters) In(args ...sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude User with a specific DeletedAt value
func (UserDeletedAtFilters) NotIn(args ...sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(users.deleted_at = ANY($1))", pq.Array(args))
	}
}

// Filter to only include User when DeletedAt happen after $value
func (UserDeletedAtFilters) After(val sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at > $1", val)
	}
}

// Filter to only include User when DeletedAt happen before $value
func (UserDeletedAtFilters) Before(val sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at < $1", val)
	}
}

// Filter to only include User when DeletedAt happen between $low and $high
func (UserDeletedAtFilters) Between(low sql.NullTime, high sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at BETWEEN $1 AND $2", low, high)
	}
}

// Filter to only include User when DeletedAt IS NULL
func (UserDeletedAtFilters) IsNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at IS NULL")
	}
}

// Filter to exclude User when DeletedAt IS NULL
func (UserDeletedAtFilters) IsNotNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("users.deleted_at IS NOT NULL")
	}
}

// Filter to sort User by DeletedAt is ASC order
func (UserDeletedAtFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.deleted_at DESC")
	}
}

// Filter to sort User by DeletedAt is DESC order
func (UserDeletedAtFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("users.deleted_at DESC")
	}
}

func (UserFilters) Offset(val uint64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Offset(val)
	}
}

func (UserFilters) Limit(val uint64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Limit(val)
	}
}

func (UserFilters) Distinct() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Distinct()
	}
}

func (UserFilters) GroupBy(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.GroupBy(args...)
	}
}

// Table items

var ItemFields = []string{"id", "name", "quantity", "user_id", "created_at", "updated_at", "deleted_at"}

type ItemPrimaryKey = uuid.UUID

type ItemModel struct {
	Id        uuid.UUID    `json:"id" db:"id"`
	Name      string       `json:"name" db:"name"`
	Quantity  int64        `json:"quantity" db:"quantity"`
	UserId    *uuid.UUID   `json:"user_id" db:"user_id"`
	CreatedAt time.Time    `json:"created_at" db:"created_at"`
	UpdatedAt time.Time    `json:"updated_at" db:"updated_at"`
	DeletedAt sql.NullTime `json:"deleted_at" db:"deleted_at"`
}

type ItemCreate struct {
	Name     string     `json:"name" db:"name"`
	Quantity int64      `json:"quantity" db:"quantity"`
	UserId   *uuid.UUID `json:"user_id" db:"user_id"`
}

type ItemUpdate struct {
	Id       uuid.UUID  `json:"id" db:"id"`
	Name     string     `json:"name" db:"name"`
	Quantity int64      `json:"quantity" db:"quantity"`
	UserId   *uuid.UUID `json:"user_id" db:"user_id"`
}

type ItemQueries struct {
	ctx *DBContext
	// Used to modify Item queries (filter, pagination, search, ...)
	//
	// Usage:
	//   users, err := db.Item.FindMany(
	//     db.Item.Query.DeletedAt.IsNotNull(),
	//     db.Item.Query.Name.OrderAsc(),
	//     # add more conditions ...
	//   )
	Query ItemFilters
}

type ItemFilters struct {
	Id        ItemIdFilters
	Name      ItemNameFilters
	Quantity  ItemQuantityFilters
	UserId    ItemUserIdFilters
	CreatedAt ItemCreatedAtFilters
	UpdatedAt ItemUpdatedAtFilters
	DeletedAt ItemDeletedAtFilters
}

type ItemIdFilters struct{}
type ItemNameFilters struct{}
type ItemQuantityFilters struct{}
type ItemUserIdFilters struct{}
type ItemCreatedAtFilters struct{}
type ItemUpdatedAtFilters struct{}
type ItemDeletedAtFilters struct{}

// Create a new ItemModel instance (not automatically saved in database)
//
// Example :
//
//	items = db.Item.New()
//	items.Name = "newName"
//	// ... manipulate the items entity
//	err = items.Save(db)
func (q *ItemQueries) New() *ItemModel {
	return &ItemModel{
		Id: uuid.New(),
	}
}

// Save a ItemModel
//
// Usage:
//
//	user, err = db.User.FindById(id)
//	user.Name = "newName"
//	err = user.Save(db)
func (q *ItemModel) Save(db *DBClient) error {
	data, err := db.Item.Upsert(ItemUpdate{
		Id:       q.Id,
		Name:     q.Name,
		Quantity: q.Quantity,
		UserId:   q.UserId,
	})
	*q = *data
	return err
}

// Insert a Item and return the created row
//
// Usage:
//
//	entity, err := db.Item.Insert(ItemCreate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) VALUES ($1, $2, $3, $4, NOW(), NOW()) RETURNING id, name, quantity, user_id, created_at, updated_at, deleted_at
func (q *ItemQueries) Insert(input ItemCreate) (*ItemModel, error) {
	data := &ItemModel{}
	if err := q.ctx.queryOne(data, itemCreateSql, uuid.New(), input.Name, input.Quantity, input.UserId); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Insert Item
//
// Usage:
//
//	entities, err := db.Item.InsertMany([]ItemCreate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) SELECT *, NOW(), NOW() FROM jsonb_to_recordset($1) as t(id UUID, name TEXT, quantity INT8, user_id UUID) RETURNING items.id
func (q *ItemQueries) InsertMany(inputs []ItemCreate) ([]ItemPrimaryKey, error) {
	ids := []ItemPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		records := make([]ItemUpdate, len(chunk))
		for i, input := range chunk {
			records[i] = ItemUpdate{
				Id:       uuid.New(),
				Name:     input.Name,
				Quantity: input.Quantity,
				UserId:   input.UserId,
			}
		}

		data, err := json.Marshal(records)
		if err != nil {
			return nil, err
		}

		loopIds := []ItemPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, itemCreateManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Upsert a Item (create or update if already exist) and return the updated row
//
// Usage:
//
//	entity, err := db.Item.Upsert(ItemUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) VALUES ($1, $2, $3, $4, NOW(), NOW()) ON CONFLICT(id) DO UPDATE SET name=EXCLUDED.name, quantity=EXCLUDED.quantity, user_id=EXCLUDED.user_id, updated_at=NOW() RETURNING id, name, quantity, user_id, created_at, updated_at, deleted_at
func (q *ItemQueries) Upsert(input ItemUpdate) (*ItemModel, error) {
	data := &ItemModel{}
	if err := q.ctx.queryOne(data, itemUpsertSql, input.Id, input.Name, input.Quantity, input.UserId); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Upsert Item (create or update if already exist)
//
// Usage:
//
//	entities, err := db.Item.UpsertMany([]ItemUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO items (id, name, quantity, user_id, created_at, updated_at) SELECT *, NOW(), NOW() FROM jsonb_to_recordset($1) as t(id UUID, name TEXT, quantity INT8, user_id UUID) ON CONFLICT(id) DO UPDATE SET name=EXCLUDED.name, quantity=EXCLUDED.quantity, user_id=EXCLUDED.user_id RETURNING items.id
func (q *ItemQueries) UpsertMany(inputs []ItemUpdate) ([]ItemPrimaryKey, error) {
	ids := []ItemPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []ItemPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, itemUpsertManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Update a Item and return the updated row
//
// Usage:
//
//	entity, err := db.Item.Update(ItemUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	UPDATE items SET name=$2, quantity=$3, user_id=$4, updated_at=NOW() WHERE id=$1 RETURNING id, name, quantity, user_id, created_at, updated_at, deleted_at
func (q *ItemQueries) Update(input ItemUpdate) (*ItemModel, error) {
	data := &ItemModel{}
	if err := q.ctx.queryOne(data, itemUpdateSql, input.Id, input.Name, input.Quantity, input.UserId); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Update Item
//
// Usage:
//
//	entities, err := db.Item.UpdateMany([]ItemUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	UPDATE items SET name=t.name, quantity=t.quantity, user_id=t.user_id FROM jsonb_to_recordset($1) as t(id UUID, name TEXT, quantity INT8, user_id UUID) WHERE items.id=t.id RETURNING items.id
func (q *ItemQueries) UpdateMany(inputs []ItemUpdate) ([]ItemPrimaryKey, error) {
	ids := []ItemPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []ItemPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, itemUpdateManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Delete a Item (soft delete, data are still in the database)
//
// Usage:
//
//	err := db.Item.DeleteSoft(id)
//
// SQL Statement:
//
//	UPDATE items SET deleted_at=NOW() WHERE id=$1
func (q *ItemQueries) DeleteSoft(id ItemPrimaryKey) error {
	return q.ctx.exec(itemDeleteSoftSql, id)
}

// Delete a Item (soft delete, data are still in the database)
func (q *ItemModel) DeleteSoft(db *DBClient) error {
	return db.Item.DeleteSoft(q.Id)
}

// Delete a Item (hard delete, data are removed from the database)
//
// Usage:
//
//	err := db.Item.DeleteHard(id)
//
// SQL Statement:
//
//	DELETE FROM items WHERE id=$1
func (q *ItemQueries) DeleteHard(id ItemPrimaryKey) error {
	return q.ctx.exec(itemDeleteHardSql, id)
}

// Delete a Item (hard delete, data are removed from the database)
func (q *ItemModel) DeleteHard(db *DBClient) error {
	return db.Item.DeleteHard(q.Id)
}

// Count Item records based on filter conditions
//
// Usage:
//
//	count, err := db.Item.Count(
//	  // ... can use filters here (cf db.Item.Query.*)
//	)
func (q *ItemQueries) Count(filters ...WhereCondition) (int, error) {
	query := squirrel.Select("count(id)").From(itemTable).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = q.ctx.queryOne(&count, sql, args...)
	return count, err
}

// Find Item records based on the provided conditions
//
// Usage:
//
//	entities, err := db.Item.FindMany(
//	  // ... can use filters here (cf db.Item.Query.*)
//	)
func (q *ItemQueries) FindMany(filters ...WhereCondition) ([]ItemModel, error) {
	query := squirrel.Select(ItemFields...).From(itemTable).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []ItemModel{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

// Find one Item records based on the provided conditions
//
// Usage:
//
//	entity, err := db.Item.FindUnique(
//	  // ... can use filters here (cf db.Item.Query.*)
//	)
func (q *ItemQueries) FindUnique(filters ...WhereCondition) (*ItemModel, error) {
	filters = append(filters, limitFirst)
	return first(q.FindMany(filters...))
}

// Find Item By PrimaryKey
//
// Usage:
//
//	entity, err := db.Item.FindById(id)
func (q *ItemQueries) FindById(id ItemPrimaryKey) (*ItemModel, error) {
	return q.FindUnique(func(cond SelectBuilder) SelectBuilder {
		return cond.Where("id = $1", id)
	})
}

// Batch Find Item By PrimaryKey
//
// Usage:
//
//	entities, err := db.Item.FindByIds(ids)
func (q *ItemQueries) FindByIds(ids ...ItemPrimaryKey) ([]ItemModel, error) {
	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
		return cond.Where("id = ANY($1)", pq.Array(ids))
	})
}

// Filter to only include Item with a specific Id value
func (ItemIdFilters) Equal(arg uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.id = $1", arg)
	}
}

// Filter to exclude Item with a specific Id value
func (ItemIdFilters) NotEqual(arg uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.id != $1", arg)
	}
}

// Filter to only include Item with a specific Id value
func (ItemIdFilters) In(args ...uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.id = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific Id value
func (ItemIdFilters) NotIn(args ...uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.id = ANY($1))", pq.Array(args))
	}
}

// Filter to sort Item by Id is ASC order
func (ItemIdFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.id DESC")
	}
}

// Filter to sort Item by Id is DESC order
func (ItemIdFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.id DESC")
	}
}

// Filter to only include Item with a specific Name value
func (ItemNameFilters) Equal(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.name = $1", arg)
	}
}

// Filter to exclude Item with a specific Name value
func (ItemNameFilters) NotEqual(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.name != $1", arg)
	}
}

// Filter to only include Item with a specific Name value
func (ItemNameFilters) In(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.name = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific Name value
func (ItemNameFilters) NotIn(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.name = ANY($1))", pq.Array(args))
	}
}

// Filter to only include Item when Name is LIKE $value
func (ItemNameFilters) Like(search string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.name ILIKE $1", search)
	}
}

// Filter to sort Item by Name is ASC order
func (ItemNameFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.name DESC")
	}
}

// Filter to sort Item by Name is DESC order
func (ItemNameFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.name DESC")
	}
}

// Filter to only include Item with a specific Quantity value
func (ItemQuantityFilters) Equal(arg int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity = $1", arg)
	}
}

// Filter to exclude Item with a specific Quantity value
func (ItemQuantityFilters) NotEqual(arg int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity != $1", arg)
	}
}

// Filter to only include Item with a specific Quantity value
func (ItemQuantityFilters) In(args ...int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific Quantity value
func (ItemQuantityFilters) NotIn(args ...int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.quantity = ANY($1))", pq.Array(args))
	}
}

// Filter to only include Item when Quantity > $value
func (ItemQuantityFilters) GreaterThan(val int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity > $1", val)
	}
}

// Filter to only include Item when Quantity >= $value
func (ItemQuantityFilters) GreaterThanOrEqual(val int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity >= $1", val)
	}
}

// Filter to only include Item when Quantity > $value
func (ItemQuantityFilters) LesserThan(val int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity < $1", val)
	}
}

// Filter to include Item only when Quantity <= $value
func (ItemQuantityFilters) LesserThanOrEqual(val int64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.quantity <= $1", val)
	}
}

// Filter to sort Item by Quantity is ASC order
func (ItemQuantityFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.quantity DESC")
	}
}

// Filter to sort Item by Quantity is DESC order
func (ItemQuantityFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.quantity DESC")
	}
}

// Filter to only include Item with a specific UserId value
func (ItemUserIdFilters) Equal(arg *uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.user_id = $1", arg)
	}
}

// Filter to exclude Item with a specific UserId value
func (ItemUserIdFilters) NotEqual(arg *uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.user_id != $1", arg)
	}
}

// Filter to only include Item with a specific UserId value
func (ItemUserIdFilters) In(args ...*uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.user_id = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific UserId value
func (ItemUserIdFilters) NotIn(args ...*uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.user_id = ANY($1))", pq.Array(args))
	}
}

// Filter to only include Item when UserId IS NULL
func (ItemUserIdFilters) IsNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.user_id IS NULL")
	}
}

// Filter to exclude Item when UserId IS NULL
func (ItemUserIdFilters) IsNotNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.user_id IS NOT NULL")
	}
}

// Filter to sort Item by UserId is ASC order
func (ItemUserIdFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.user_id DESC")
	}
}

// Filter to sort Item by UserId is DESC order
func (ItemUserIdFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.user_id DESC")
	}
}

// Filter to only include Item with a specific CreatedAt value
func (ItemCreatedAtFilters) Equal(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.created_at = $1", arg)
	}
}

// Filter to exclude Item with a specific CreatedAt value
func (ItemCreatedAtFilters) NotEqual(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.created_at != $1", arg)
	}
}

// Filter to only include Item with a specific CreatedAt value
func (ItemCreatedAtFilters) In(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.created_at = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific CreatedAt value
func (ItemCreatedAtFilters) NotIn(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.created_at = ANY($1))", pq.Array(args))
	}
}

// Filter to only include Item when CreatedAt happen after $value
func (ItemCreatedAtFilters) After(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.created_at > $1", val)
	}
}

// Filter to only include Item when CreatedAt happen before $value
func (ItemCreatedAtFilters) Before(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.created_at < $1", val)
	}
}

// Filter to only include Item when CreatedAt happen between $low and $high
func (ItemCreatedAtFilters) Between(low time.Time, high time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.created_at BETWEEN $1 AND $2", low, high)
	}
}

// Filter to sort Item by CreatedAt is ASC order
func (ItemCreatedAtFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.created_at DESC")
	}
}

// Filter to sort Item by CreatedAt is DESC order
func (ItemCreatedAtFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.created_at DESC")
	}
}

// Filter to only include Item with a specific UpdatedAt value
func (ItemUpdatedAtFilters) Equal(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.updated_at = $1", arg)
	}
}

// Filter to exclude Item with a specific UpdatedAt value
func (ItemUpdatedAtFilters) NotEqual(arg time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.updated_at != $1", arg)
	}
}

// Filter to only include Item with a specific UpdatedAt value
func (ItemUpdatedAtFilters) In(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.updated_at = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific UpdatedAt value
func (ItemUpdatedAtFilters) NotIn(args ...time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.updated_at = ANY($1))", pq.Array(args))
	}
}

// Filter to only include Item when UpdatedAt happen after $value
func (ItemUpdatedAtFilters) After(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.updated_at > $1", val)
	}
}

// Filter to only include Item when UpdatedAt happen before $value
func (ItemUpdatedAtFilters) Before(val time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.updated_at < $1", val)
	}
}

// Filter to only include Item when UpdatedAt happen between $low and $high
func (ItemUpdatedAtFilters) Between(low time.Time, high time.Time) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.updated_at BETWEEN $1 AND $2", low, high)
	}
}

// Filter to sort Item by UpdatedAt is ASC order
func (ItemUpdatedAtFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.updated_at DESC")
	}
}

// Filter to sort Item by UpdatedAt is DESC order
func (ItemUpdatedAtFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.updated_at DESC")
	}
}

// Filter to only include Item with a specific DeletedAt value
func (ItemDeletedAtFilters) Equal(arg sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at = $1", arg)
	}
}

// Filter to exclude Item with a specific DeletedAt value
func (ItemDeletedAtFilters) NotEqual(arg sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at != $1", arg)
	}
}

// Filter to only include Item with a specific DeletedAt value
func (ItemDeletedAtFilters) In(args ...sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude Item with a specific DeletedAt value
func (ItemDeletedAtFilters) NotIn(args ...sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(items.deleted_at = ANY($1))", pq.Array(args))
	}
}

// Filter to only include Item when DeletedAt happen after $value
func (ItemDeletedAtFilters) After(val sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at > $1", val)
	}
}

// Filter to only include Item when DeletedAt happen before $value
func (ItemDeletedAtFilters) Before(val sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at < $1", val)
	}
}

// Filter to only include Item when DeletedAt happen between $low and $high
func (ItemDeletedAtFilters) Between(low sql.NullTime, high sql.NullTime) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at BETWEEN $1 AND $2", low, high)
	}
}

// Filter to only include Item when DeletedAt IS NULL
func (ItemDeletedAtFilters) IsNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at IS NULL")
	}
}

// Filter to exclude Item when DeletedAt IS NULL
func (ItemDeletedAtFilters) IsNotNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("items.deleted_at IS NOT NULL")
	}
}

// Filter to sort Item by DeletedAt is ASC order
func (ItemDeletedAtFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.deleted_at DESC")
	}
}

// Filter to sort Item by DeletedAt is DESC order
func (ItemDeletedAtFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("items.deleted_at DESC")
	}
}

func (ItemFilters) Offset(val uint64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Offset(val)
	}
}

func (ItemFilters) Limit(val uint64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Limit(val)
	}
}

func (ItemFilters) Distinct() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Distinct()
	}
}

func (ItemFilters) GroupBy(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.GroupBy(args...)
	}
}

// Table item_meta

var ItemMetaFields = []string{"id", "key", "value", "item_id"}

type ItemMetaPrimaryKey = uuid.UUID

type ItemMetaModel struct {
	Id     uuid.UUID  `json:"id" db:"id"`
	Key    string     `json:"key" db:"key"`
	Value  string     `json:"value" db:"value"`
	ItemId *uuid.UUID `json:"item_id" db:"item_id"`
}

type ItemMetaCreate struct {
	Key    string     `json:"key" db:"key"`
	Value  string     `json:"value" db:"value"`
	ItemId *uuid.UUID `json:"item_id" db:"item_id"`
}

type ItemMetaUpdate struct {
	Id     uuid.UUID  `json:"id" db:"id"`
	Key    string     `json:"key" db:"key"`
	Value  string     `json:"value" db:"value"`
	ItemId *uuid.UUID `json:"item_id" db:"item_id"`
}

type ItemMetaQueries struct {
	ctx *DBContext
	// Used to modify ItemMeta queries (filter, pagination, search, ...)
	//
	// Usage:
	//   users, err := db.ItemMeta.FindMany(
	//     db.ItemMeta.Query.DeletedAt.IsNotNull(),
	//     db.ItemMeta.Query.Name.OrderAsc(),
	//     # add more conditions ...
	//   )
	Query ItemMetaFilters
}

type ItemMetaFilters struct {
	Id     ItemMetaIdFilters
	Key    ItemMetaKeyFilters
	Value  ItemMetaValueFilters
	ItemId ItemMetaItemIdFilters
}

type ItemMetaIdFilters struct{}
type ItemMetaKeyFilters struct{}
type ItemMetaValueFilters struct{}
type ItemMetaItemIdFilters struct{}

// Create a new ItemMetaModel instance (not automatically saved in database)
//
// Example :
//
//	item_meta = db.ItemMeta.New()
//	item_meta.Name = "newName"
//	// ... manipulate the item_meta entity
//	err = item_meta.Save(db)
func (q *ItemMetaQueries) New() *ItemMetaModel {
	return &ItemMetaModel{
		Id: uuid.New(),
	}
}

// Save a ItemMetaModel
//
// Usage:
//
//	user, err = db.User.FindById(id)
//	user.Name = "newName"
//	err = user.Save(db)
func (q *ItemMetaModel) Save(db *DBClient) error {
	data, err := db.ItemMeta.Upsert(ItemMetaUpdate{
		Id:     q.Id,
		Key:    q.Key,
		Value:  q.Value,
		ItemId: q.ItemId,
	})
	*q = *data
	return err
}

// Insert a ItemMeta and return the created row
//
// Usage:
//
//	entity, err := db.ItemMeta.Insert(ItemMetaCreate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO item_meta (id, key, value, item_id) VALUES ($1, $2, $3, $4) RETURNING id, key, value, item_id
func (q *ItemMetaQueries) Insert(input ItemMetaCreate) (*ItemMetaModel, error) {
	data := &ItemMetaModel{}
	if err := q.ctx.queryOne(data, itemMetaCreateSql, uuid.New(), input.Key, input.Value, input.ItemId); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Insert ItemMeta
//
// Usage:
//
//	entities, err := db.ItemMeta.InsertMany([]ItemMetaCreate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO item_meta (id, key, value, item_id) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, key TEXT, value TEXT, item_id UUID) RETURNING item_meta.id
func (q *ItemMetaQueries) InsertMany(inputs []ItemMetaCreate) ([]ItemMetaPrimaryKey, error) {
	ids := []ItemMetaPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		records := make([]ItemMetaUpdate, len(chunk))
		for i, input := range chunk {
			records[i] = ItemMetaUpdate{
				Id:     uuid.New(),
				Key:    input.Key,
				Value:  input.Value,
				ItemId: input.ItemId,
			}
		}

		data, err := json.Marshal(records)
		if err != nil {
			return nil, err
		}

		loopIds := []ItemMetaPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, itemMetaCreateManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Upsert a ItemMeta (create or update if already exist) and return the updated row
//
// Usage:
//
//	entity, err := db.ItemMeta.Upsert(ItemMetaUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO item_meta (id, key, value, item_id) VALUES ($1, $2, $3, $4) ON CONFLICT(id) DO UPDATE SET key=EXCLUDED.key, value=EXCLUDED.value, item_id=EXCLUDED.item_id RETURNING id, key, value, item_id
func (q *ItemMetaQueries) Upsert(input ItemMetaUpdate) (*ItemMetaModel, error) {
	data := &ItemMetaModel{}
	if err := q.ctx.queryOne(data, itemMetaUpsertSql, input.Id, input.Key, input.Value, input.ItemId); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Upsert ItemMeta (create or update if already exist)
//
// Usage:
//
//	entities, err := db.ItemMeta.UpsertMany([]ItemMetaUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	INSERT INTO item_meta (id, key, value, item_id) SELECT * FROM jsonb_to_recordset($1) as t(id UUID, key TEXT, value TEXT, item_id UUID) ON CONFLICT(id) DO UPDATE SET key=EXCLUDED.key, value=EXCLUDED.value, item_id=EXCLUDED.item_id RETURNING item_meta.id
func (q *ItemMetaQueries) UpsertMany(inputs []ItemMetaUpdate) ([]ItemMetaPrimaryKey, error) {
	ids := []ItemMetaPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []ItemMetaPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, itemMetaUpsertManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Update a ItemMeta and return the updated row
//
// Usage:
//
//	entity, err := db.ItemMeta.Update(ItemMetaUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	UPDATE item_meta SET key=$2, value=$3, item_id=$4 WHERE id=$1 RETURNING id, key, value, item_id
func (q *ItemMetaQueries) Update(input ItemMetaUpdate) (*ItemMetaModel, error) {
	data := &ItemMetaModel{}
	if err := q.ctx.queryOne(data, itemMetaUpdateSql, input.Id, input.Key, input.Value, input.ItemId); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Update ItemMeta
//
// Usage:
//
//	entities, err := db.ItemMeta.UpdateMany([]ItemMetaUpdate{
//	  // ...
//	})
//
// SQL Statement:
//
//	UPDATE item_meta SET key=t.key, value=t.value, item_id=t.item_id FROM jsonb_to_recordset($1) as t(id UUID, key TEXT, value TEXT, item_id UUID) WHERE item_meta.id=t.id RETURNING item_meta.id
func (q *ItemMetaQueries) UpdateMany(inputs []ItemMetaUpdate) ([]ItemMetaPrimaryKey, error) {
	ids := []ItemMetaPrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []ItemMetaPrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, itemMetaUpdateManySql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Delete a ItemMeta (hard delete, data are removed from the database)
//
// Usage:
//
//	err := db.ItemMeta.DeleteHard(id)
//
// SQL Statement:
//
//	DELETE FROM item_meta WHERE id=$1
func (q *ItemMetaQueries) DeleteHard(id ItemMetaPrimaryKey) error {
	return q.ctx.exec(itemMetaDeleteHardSql, id)
}

// Delete a ItemMeta (hard delete, data are removed from the database)
func (q *ItemMetaModel) DeleteHard(db *DBClient) error {
	return db.ItemMeta.DeleteHard(q.Id)
}

// Count ItemMeta records based on filter conditions
//
// Usage:
//
//	count, err := db.ItemMeta.Count(
//	  // ... can use filters here (cf db.ItemMeta.Query.*)
//	)
func (q *ItemMetaQueries) Count(filters ...WhereCondition) (int, error) {
	query := squirrel.Select("count(id)").From(itemMetaTable).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = q.ctx.queryOne(&count, sql, args...)
	return count, err
}

// Find ItemMeta records based on the provided conditions
//
// Usage:
//
//	entities, err := db.ItemMeta.FindMany(
//	  // ... can use filters here (cf db.ItemMeta.Query.*)
//	)
func (q *ItemMetaQueries) FindMany(filters ...WhereCondition) ([]ItemMetaModel, error) {
	query := squirrel.Select(ItemMetaFields...).From(itemMetaTable).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []ItemMetaModel{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

// Find one ItemMeta records based on the provided conditions
//
// Usage:
//
//	entity, err := db.ItemMeta.FindUnique(
//	  // ... can use filters here (cf db.ItemMeta.Query.*)
//	)
func (q *ItemMetaQueries) FindUnique(filters ...WhereCondition) (*ItemMetaModel, error) {
	filters = append(filters, limitFirst)
	return first(q.FindMany(filters...))
}

// Find ItemMeta By PrimaryKey
//
// Usage:
//
//	entity, err := db.ItemMeta.FindById(id)
func (q *ItemMetaQueries) FindById(id ItemMetaPrimaryKey) (*ItemMetaModel, error) {
	return q.FindUnique(func(cond SelectBuilder) SelectBuilder {
		return cond.Where("id = $1", id)
	})
}

// Batch Find ItemMeta By PrimaryKey
//
// Usage:
//
//	entities, err := db.ItemMeta.FindByIds(ids)
func (q *ItemMetaQueries) FindByIds(ids ...ItemMetaPrimaryKey) ([]ItemMetaModel, error) {
	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
		return cond.Where("id = ANY($1)", pq.Array(ids))
	})
}

// Filter to only include ItemMeta with a specific Id value
func (ItemMetaIdFilters) Equal(arg uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.id = $1", arg)
	}
}

// Filter to exclude ItemMeta with a specific Id value
func (ItemMetaIdFilters) NotEqual(arg uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.id != $1", arg)
	}
}

// Filter to only include ItemMeta with a specific Id value
func (ItemMetaIdFilters) In(args ...uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.id = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude ItemMeta with a specific Id value
func (ItemMetaIdFilters) NotIn(args ...uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(item_meta.id = ANY($1))", pq.Array(args))
	}
}

// Filter to sort ItemMeta by Id is ASC order
func (ItemMetaIdFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.id DESC")
	}
}

// Filter to sort ItemMeta by Id is DESC order
func (ItemMetaIdFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.id DESC")
	}
}

// Filter to only include ItemMeta with a specific Key value
func (ItemMetaKeyFilters) Equal(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.key = $1", arg)
	}
}

// Filter to exclude ItemMeta with a specific Key value
func (ItemMetaKeyFilters) NotEqual(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.key != $1", arg)
	}
}

// Filter to only include ItemMeta with a specific Key value
func (ItemMetaKeyFilters) In(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.key = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude ItemMeta with a specific Key value
func (ItemMetaKeyFilters) NotIn(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(item_meta.key = ANY($1))", pq.Array(args))
	}
}

// Filter to only include ItemMeta when Key is LIKE $value
func (ItemMetaKeyFilters) Like(search string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.key ILIKE $1", search)
	}
}

// Filter to sort ItemMeta by Key is ASC order
func (ItemMetaKeyFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.key DESC")
	}
}

// Filter to sort ItemMeta by Key is DESC order
func (ItemMetaKeyFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.key DESC")
	}
}

// Filter to only include ItemMeta with a specific Value value
func (ItemMetaValueFilters) Equal(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.value = $1", arg)
	}
}

// Filter to exclude ItemMeta with a specific Value value
func (ItemMetaValueFilters) NotEqual(arg string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.value != $1", arg)
	}
}

// Filter to only include ItemMeta with a specific Value value
func (ItemMetaValueFilters) In(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.value = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude ItemMeta with a specific Value value
func (ItemMetaValueFilters) NotIn(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(item_meta.value = ANY($1))", pq.Array(args))
	}
}

// Filter to only include ItemMeta when Value is LIKE $value
func (ItemMetaValueFilters) Like(search string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.value ILIKE $1", search)
	}
}

// Filter to sort ItemMeta by Value is ASC order
func (ItemMetaValueFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.value DESC")
	}
}

// Filter to sort ItemMeta by Value is DESC order
func (ItemMetaValueFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.value DESC")
	}
}

// Filter to only include ItemMeta with a specific ItemId value
func (ItemMetaItemIdFilters) Equal(arg *uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.item_id = $1", arg)
	}
}

// Filter to exclude ItemMeta with a specific ItemId value
func (ItemMetaItemIdFilters) NotEqual(arg *uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.item_id != $1", arg)
	}
}

// Filter to only include ItemMeta with a specific ItemId value
func (ItemMetaItemIdFilters) In(args ...*uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.item_id = ANY($1)", pq.Array(args))
	}
}

// Filter to exclude ItemMeta with a specific ItemId value
func (ItemMetaItemIdFilters) NotIn(args ...*uuid.UUID) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("NOT(item_meta.item_id = ANY($1))", pq.Array(args))
	}
}

// Filter to only include ItemMeta when ItemId IS NULL
func (ItemMetaItemIdFilters) IsNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.item_id IS NULL")
	}
}

// Filter to exclude ItemMeta when ItemId IS NULL
func (ItemMetaItemIdFilters) IsNotNull() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Where("item_meta.item_id IS NOT NULL")
	}
}

// Filter to sort ItemMeta by ItemId is ASC order
func (ItemMetaItemIdFilters) OrderAsc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.item_id DESC")
	}
}

// Filter to sort ItemMeta by ItemId is DESC order
func (ItemMetaItemIdFilters) OrderDesc() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.OrderBy("item_meta.item_id DESC")
	}
}

func (ItemMetaFilters) Offset(val uint64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Offset(val)
	}
}

func (ItemMetaFilters) Limit(val uint64) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Limit(val)
	}
}

func (ItemMetaFilters) Distinct() WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.Distinct()
	}
}

func (ItemMetaFilters) GroupBy(args ...string) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond.GroupBy(args...)
	}
}

// Find Item By ForeignKey User
//
//func (q *ItemQueries) GetByUserId(user_id *uuid.UUID, ) ([]ItemModel, error) {
//	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
//		return cond.Where("user_id = ?", user_id)
//	})
//}

// Find Relation User's childs (Item > User)
//func (q *UserModel) Items(db *DBClient) ([]ItemModel, error) {
//	return db.Item.GetByUserId(&q.Id)
//}

// Find Relation Item's parent (Item > User)
//func (q *ItemModel) User(db *DBClient) (*UserModel, error) {
//	return db.User.FindById(*q.UserId, )
//}

// Find ItemMeta By ForeignKey Item
//
//func (q *ItemMetaQueries) GetByItemId(item_id *uuid.UUID, ) ([]ItemMetaModel, error) {
//	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
//		return cond.Where("item_id = ?", item_id)
//	})
//}

// Find Relation Item's childs (ItemMeta > Item)
//func (q *ItemModel) ItemMetas(db *DBClient) ([]ItemMetaModel, error) {
//	return db.ItemMeta.GetByItemId(&q.Id)
//}

// Find Relation ItemMeta's parent (ItemMeta > Item)
//func (q *ItemMetaModel) Item(db *DBClient) (*ItemModel, error) {
//	return db.Item.FindById(*q.ItemId, )
//}

type CustomQueries struct {
	ctx *DBContext
}

// Find UserItems records based on the provided conditions
//
// Usage:
//   entities, err := db.Queries.UserItems(
//     // ... can use filters here (cf db.UserItems.Query.*)
//   )
//
// SQL Statement:
//   SELECT * FROM users AS u INNER JOIN items ON items.user_id = users.id WHERE users.deleted_at IS NULL
func (q *CustomQueries) UserItems(filters ...WhereCondition) ([]UserItemsModel, error) {
	query := squirrel.Select("u.id AS u_id, u.email AS u_email, u.name AS u_name, u.created_at AS u_created_at, u.updated_at AS u_updated_at, u.deleted_at AS u_deleted_at, items.id AS items_id_1, items.name AS items_name_1, items.quantity AS items_quantity_1, items.user_id AS items_user_id_1, items.created_at AS items_created_at_1, items.updated_at AS items_updated_at_1, items.deleted_at AS items_deleted_at_1")
	query = query.From("users AS u INNER JOIN items ON items.user_id = users.id").PlaceholderFormat(squirrel.Dollar)
	query = query.Where("users.deleted_at IS NULL")
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []UserItemsModel{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

type UserItemsModel struct {
	Uid            uuid.UUID    `json:"u_id" db:"u_id"`
	Uemail         string       `json:"u_email" db:"u_email"`
	Uname          string       `json:"u_name" db:"u_name"`
	UcreatedAt     time.Time    `json:"u_created_at" db:"u_created_at"`
	UupdatedAt     time.Time    `json:"u_updated_at" db:"u_updated_at"`
	UdeletedAt     sql.NullTime `json:"u_deleted_at" db:"u_deleted_at"`
	ItemsId        uuid.UUID    `json:"items_id_1" db:"items_id_1"`
	ItemsName      string       `json:"items_name_1" db:"items_name_1"`
	ItemsQuantity  int64        `json:"items_quantity_1" db:"items_quantity_1"`
	ItemsUserId    *uuid.UUID   `json:"items_user_id_1" db:"items_user_id_1"`
	ItemsCreatedAt time.Time    `json:"items_created_at_1" db:"items_created_at_1"`
	ItemsUpdatedAt time.Time    `json:"items_updated_at_1" db:"items_updated_at_1"`
	ItemsDeletedAt sql.NullTime `json:"items_deleted_at_1" db:"items_deleted_at_1"`
}

// Find UserItems2 records based on the provided conditions
//
// Usage:
//   entities, err := db.Queries.UserItems2(
//     // ... can use filters here (cf db.UserItems2.Query.*)
//   )
//
// SQL Statement:
//   SELECT users.*, items.id FROM users INNER JOIN items ON items.user_id = users.id WHERE users.deleted_at IS NULL
func (q *CustomQueries) UserItems2(filters ...WhereCondition) ([]UserItems2Model, error) {
	query := squirrel.Select("users.id AS users_id, users.email AS users_email, users.name AS users_name, users.created_at AS users_created_at, users.updated_at AS users_updated_at, users.deleted_at AS users_deleted_at, items.id AS items_id_1")
	query = query.From("users INNER JOIN items ON items.user_id = users.id").PlaceholderFormat(squirrel.Dollar)
	query = query.Where("users.deleted_at IS NULL")
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []UserItems2Model{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

type UserItems2Model struct {
	UsersId        uuid.UUID    `json:"users_id" db:"users_id"`
	UsersEmail     string       `json:"users_email" db:"users_email"`
	UsersName      string       `json:"users_name" db:"users_name"`
	UsersCreatedAt time.Time    `json:"users_created_at" db:"users_created_at"`
	UsersUpdatedAt time.Time    `json:"users_updated_at" db:"users_updated_at"`
	UsersDeletedAt sql.NullTime `json:"users_deleted_at" db:"users_deleted_at"`
	ItemsId        uuid.UUID    `json:"items_id_1" db:"items_id_1"`
}

// Find UserItems3 records based on the provided conditions
//
// Usage:
//   entities, err := db.Queries.UserItems3(
//     // ... can use filters here (cf db.UserItems3.Query.*)
//   )
//
// SQL Statement:
//   SELECT * FROM users INNER JOIN items AS items1 ON i1.user_id = users.id INNER JOIN items AS items2 ON i2.id = i1.id INNER JOIN items AS items3 ON i3.id = i2.id WHERE users.deleted_at IS NULL
func (q *CustomQueries) UserItems3(filters ...WhereCondition) ([]UserItems3Model, error) {
	query := squirrel.Select("users.id AS users_id, users.email AS users_email, users.name AS users_name, users.created_at AS users_created_at, users.updated_at AS users_updated_at, users.deleted_at AS users_deleted_at, items1.id AS items_1_id_1, items1.name AS items_1_name_1, items1.quantity AS items_1_quantity_1, items1.user_id AS items_1_user_id_1, items1.created_at AS items_1_created_at_1, items1.updated_at AS items_1_updated_at_1, items1.deleted_at AS items_1_deleted_at_1, items2.id AS items_2_id_2, items2.name AS items_2_name_2, items2.quantity AS items_2_quantity_2, items2.user_id AS items_2_user_id_2, items2.created_at AS items_2_created_at_2, items2.updated_at AS items_2_updated_at_2, items2.deleted_at AS items_2_deleted_at_2, items3.id AS items_3_id_3, items3.name AS items_3_name_3, items3.quantity AS items_3_quantity_3, items3.user_id AS items_3_user_id_3, items3.created_at AS items_3_created_at_3, items3.updated_at AS items_3_updated_at_3, items3.deleted_at AS items_3_deleted_at_3")
	query = query.From("users INNER JOIN items AS items1 ON i1.user_id = users.id INNER JOIN items AS items2 ON i2.id = i1.id INNER JOIN items AS items3 ON i3.id = i2.id").PlaceholderFormat(squirrel.Dollar)
	query = query.Where("users.deleted_at IS NULL")
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []UserItems3Model{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

type UserItems3Model struct {
	UsersId         uuid.UUID    `json:"users_id" db:"users_id"`
	UsersEmail      string       `json:"users_email" db:"users_email"`
	UsersName       string       `json:"users_name" db:"users_name"`
	UsersCreatedAt  time.Time    `json:"users_created_at" db:"users_created_at"`
	UsersUpdatedAt  time.Time    `json:"users_updated_at" db:"users_updated_at"`
	UsersDeletedAt  sql.NullTime `json:"users_deleted_at" db:"users_deleted_at"`
	Items1Id        uuid.UUID    `json:"items_1_id_1" db:"items_1_id_1"`
	Items1Name      string       `json:"items_1_name_1" db:"items_1_name_1"`
	Items1Quantity  int64        `json:"items_1_quantity_1" db:"items_1_quantity_1"`
	Items1UserId    *uuid.UUID   `json:"items_1_user_id_1" db:"items_1_user_id_1"`
	Items1CreatedAt time.Time    `json:"items_1_created_at_1" db:"items_1_created_at_1"`
	Items1UpdatedAt time.Time    `json:"items_1_updated_at_1" db:"items_1_updated_at_1"`
	Items1DeletedAt sql.NullTime `json:"items_1_deleted_at_1" db:"items_1_deleted_at_1"`
	Items2Id        uuid.UUID    `json:"items_2_id_2" db:"items_2_id_2"`
	Items2Name      string       `json:"items_2_name_2" db:"items_2_name_2"`
	Items2Quantity  int64        `json:"items_2_quantity_2" db:"items_2_quantity_2"`
	Items2UserId    *uuid.UUID   `json:"items_2_user_id_2" db:"items_2_user_id_2"`
	Items2CreatedAt time.Time    `json:"items_2_created_at_2" db:"items_2_created_at_2"`
	Items2UpdatedAt time.Time    `json:"items_2_updated_at_2" db:"items_2_updated_at_2"`
	Items2DeletedAt sql.NullTime `json:"items_2_deleted_at_2" db:"items_2_deleted_at_2"`
	Items3Id        uuid.UUID    `json:"items_3_id_3" db:"items_3_id_3"`
	Items3Name      string       `json:"items_3_name_3" db:"items_3_name_3"`
	Items3Quantity  int64        `json:"items_3_quantity_3" db:"items_3_quantity_3"`
	Items3UserId    *uuid.UUID   `json:"items_3_user_id_3" db:"items_3_user_id_3"`
	Items3CreatedAt time.Time    `json:"items_3_created_at_3" db:"items_3_created_at_3"`
	Items3UpdatedAt time.Time    `json:"items_3_updated_at_3" db:"items_3_updated_at_3"`
	Items3DeletedAt sql.NullTime `json:"items_3_deleted_at_3" db:"items_3_deleted_at_3"`
}

// Find UserItemsCount records based on the provided conditions
//
// Usage:
//   entities, err := db.Queries.UserItemsCount(
//     // ... can use filters here (cf db.UserItemsCount.Query.*)
//   )
//
// SQL Statement:
//   SELECT users.*, count(items.id) AS count, sum(items.quantity) AS sum FROM users INNER JOIN items ON items.user_id = users.id WHERE users.deleted_at IS NULL GROUP BY users.id
func (q *CustomQueries) UserItemsCount(filters ...WhereCondition) ([]UserItemsCountModel, error) {
	query := squirrel.Select("users.id AS users_id, users.email AS users_email, users.name AS users_name, users.created_at AS users_created_at, users.updated_at AS users_updated_at, users.deleted_at AS users_deleted_at, count(items.id) AS count, sum(items.quantity) AS sum")
	query = query.From("users INNER JOIN items ON items.user_id = users.id").PlaceholderFormat(squirrel.Dollar)
	query = query.Where("users.deleted_at IS NULL")
	query = query.GroupBy("users.id")
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []UserItemsCountModel{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

type UserItemsCountModel struct {
	UsersId        uuid.UUID    `json:"users_id" db:"users_id"`
	UsersEmail     string       `json:"users_email" db:"users_email"`
	UsersName      string       `json:"users_name" db:"users_name"`
	UsersCreatedAt time.Time    `json:"users_created_at" db:"users_created_at"`
	UsersUpdatedAt time.Time    `json:"users_updated_at" db:"users_updated_at"`
	UsersDeletedAt sql.NullTime `json:"users_deleted_at" db:"users_deleted_at"`
	Count          int64        `json:"count" db:"count"`
	Sum            float64      `json:"sum" db:"sum"`
}

// Find Users2 records based on the provided conditions
//
// Usage:
//   entities, err := db.Queries.Users2(
//     // ... can use filters here (cf db.Users2.Query.*)
//   )
//
// SQL Statement:
//   SELECT * FROM (SELECT * FROM users WHERE deleted_at IS NULL) AS u INNER JOIN items ON items.user_id = u.id
func (q *CustomQueries) Users2(filters ...WhereCondition) ([]Users2Model, error) {
	query := squirrel.Select("items.id AS items_id_1, items.name AS items_name_1, items.quantity AS items_quantity_1, items.user_id AS items_user_id_1, items.created_at AS items_created_at_1, items.updated_at AS items_updated_at_1, items.deleted_at AS items_deleted_at_1")
	query = query.From("(SELECT * FROM users WHERE deleted_at IS NULL) AS u INNER JOIN items ON items.user_id = u.id").PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []Users2Model{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

type Users2Model struct {
	ItemsId        uuid.UUID    `json:"items_id_1" db:"items_id_1"`
	ItemsName      string       `json:"items_name_1" db:"items_name_1"`
	ItemsQuantity  int64        `json:"items_quantity_1" db:"items_quantity_1"`
	ItemsUserId    *uuid.UUID   `json:"items_user_id_1" db:"items_user_id_1"`
	ItemsCreatedAt time.Time    `json:"items_created_at_1" db:"items_created_at_1"`
	ItemsUpdatedAt time.Time    `json:"items_updated_at_1" db:"items_updated_at_1"`
	ItemsDeletedAt sql.NullTime `json:"items_deleted_at_1" db:"items_deleted_at_1"`
}
