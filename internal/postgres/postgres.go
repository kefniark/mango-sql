package postgres

import (
	"bufio"
	"bytes"
	"embed"
	"fmt"
	"io"
	"slices"
	"strings"
	"text/template"
	"time"

	"github.com/gertd/go-pluralize"
	"github.com/iancoleman/strcase"
	"github.com/kefniark/mango-sql/internal/core"
	"golang.org/x/exp/maps"
)

//go:embed templates/*.tmpl
var templates embed.FS

var plural = pluralize.NewClient()

func Generate(schema *core.SQLSchema, contents io.Writer, pkg string, driver string) error {
	headerTmpl, err := template.ParseFS(templates, fmt.Sprintf("templates/header_%s.tmpl", driver))
	if err != nil {
		return err
	}

	factoryTmpl, err := template.ParseFS(templates, fmt.Sprintf("templates/factory_%s.tmpl", driver))
	if err != nil {
		return err
	}

	ctxTmpl, err := template.ParseFS(templates, fmt.Sprintf("templates/ctx_%s.tmpl", driver))
	if err != nil {
		return err
	}

	modelTmpl, err := template.ParseFS(templates, "templates/model.tmpl")
	if err != nil {
		return err
	}

	queriesTmpl, err := template.ParseFS(templates, "templates/queries.tmpl")
	if err != nil {
		return err
	}

	// relationsTmpl, err := template.ParseFS(templates, "templates/relations.tmpl")
	// if err != nil {
	// 	return err
	// }

	customQueriesTmpl, err := template.ParseFS(templates, "templates/custom.tmpl")
	if err != nil {
		return err
	}

	tables := maps.Values(schema.Tables)
	slices.SortFunc(tables, func(i, j *core.SQLTable) int {
		return i.Order - j.Order
	})

	postgresTables := []*PostgresTable{}
	for _, table := range tables {
		entry := toPostgresTable(table)
		entry.schema = schema
		entry.table = table
		postgresTables = append(postgresTables, entry)
	}

	postgresQueries := []*PostgresQuery{}
	for _, query := range schema.Queries {
		entry := toPostgresQuery(&query)
		postgresQueries = append(postgresQueries, entry)
	}

	deps := map[string]string{}
	for _, t := range postgresTables {
		for _, c := range t.Columns {
			if strings.HasPrefix(c.Type, "uuid.") || strings.HasPrefix(c.Type, "[]uuid.") || strings.HasPrefix(c.Type, "*uuid.") {
				deps["uuid"] = "github.com/google/uuid"
			}
			if strings.HasPrefix(c.Type, "time.") || strings.HasPrefix(c.Type, "[]time.") || strings.HasPrefix(c.Type, "*time.") {
				deps["time"] = "time"
			}
			if strings.HasPrefix(c.Type, "sql.") || strings.HasPrefix(c.Type, "[]sql.") || strings.HasPrefix(c.Type, "*sql.") {
				deps["sql"] = "database/sql"
			}
		}
	}

	var ctxConstBuf bytes.Buffer
	ctxConst := bufio.NewWriter(&ctxConstBuf)
	ctxConst.Flush()

	if err = headerTmpl.Execute(contents, HeaderData{
		Package: pkg,
		Url:     "https://github.com/kefniark/mangosql",
		Date:    time.Now().String(),
		Version: "0.0.1",
		Deps:    maps.Values(deps),
	}); err != nil {
		return err
	}

	if err = factoryTmpl.Execute(contents, struct {
		Tables  []*PostgresTable
		Queries []*PostgresQuery
		Filters []FilterMethod
	}{
		Tables:  postgresTables,
		Queries: postgresQueries,
		Filters: GetFilterMethods(postgresTables),
	}); err != nil {
		return err
	}

	if err = ctxTmpl.Execute(contents, PostgresCtx{
		Const: ctxConstBuf.String(),
	}); err != nil {
		return err
	}

	for _, table := range postgresTables {
		if err = modelTmpl.Execute(contents, table); err != nil {
			return err
		}

		if err = queriesTmpl.Execute(contents, table); err != nil {
			return err
		}
	}

	if err = customQueriesTmpl.Execute(contents, postgresQueries); err != nil {
		return err
	}

	return nil
}

func toPostgresQuery(query *core.SQLQuery) *PostgresQuery {
	fields := []*PostgresColumn{}
	slices.SortFunc(query.SelectFields, func(i, j *core.SQLColumn) int {
		return i.Order - j.Order
	})
	for _, field := range query.SelectFields {
		fields = append(fields, toPostgresColumn(field))
	}

	return &PostgresQuery{
		Name:           query.Name,
		NameNormalized: strcase.ToCamel(query.Name),
		Method:         query.Method,
		Fields:         fields,
		SqlQuery:       query.Query,

		Select:         query.Select,
		SelectOriginal: query.SelectOriginal,
		From:           query.From,
		Where:          query.Where,
		GroupBy:        query.GroupBy,
		Having:         query.Having,
	}
}

func toPostgresTable(table *core.SQLTable) *PostgresTable {
	columns := []*PostgresColumn{}

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *core.SQLColumn) int {
		return i.Order - j.Order
	})

	for _, column := range cols {
		if col := toPostgresColumn(column); col != nil {
			columns = append(columns, col)
		}
	}

	return &PostgresTable{
		Name:               table.Name,
		NameNormalized:     strcase.ToCamel(plural.Singular(table.Name)),
		Columns:            columns,
		HasCompositeId:     len(getPrimaryFields(table)) > 1,
		HasIdAutoGenerated: isIdGenerated(table),
		ColumnIds:          getIdsFields(table),
		ColumnsCreate:      getCreateFields(table),
		ColumnsUpdate:      getUpdateFields(table),
		Primary:            getPrimaryFields(table),
	}
}

func toPostgresColumn(column *core.SQLColumn) *PostgresColumn {
	val := getColumnType(column)

	json := column.As
	if json == "" {
		json = strings.ToLower(strcase.ToSnake(column.Name))
	}

	name := column.Ref
	if name == "" {
		name = column.Name
	}

	return &PostgresColumn{
		Name:           name,
		NameNormalized: strcase.ToCamel(name),
		NameJson:       json,
		Type:           val,
		TypeSql:        column.TypeSql,
		Nullable:       column.Nullable,
		IsArray:        strings.Contains(column.TypeSql, "[]"),
		HasDefault:     column.HasDefault,
	}
}

func getCreateFields(table *core.SQLTable) []*PostgresColumn {
	columns := []*PostgresColumn{}
	primary := getPrimaryFields(table)

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *core.SQLColumn) int {
		return i.Order - j.Order
	})

	for _, column := range cols {
		if slices.Contains(primary, column.Name) {
			continue
		}
		if slices.Contains(getAutogeneratedFields(), column.Name) {
			continue
		}
		columns = append(columns, toPostgresColumn(column))
	}

	return columns
}

func getUpdateFields(table *core.SQLTable) []*PostgresColumn {
	columns := []*PostgresColumn{}

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *core.SQLColumn) int {
		return i.Order - j.Order
	})

	for _, column := range cols {
		if slices.Contains(getAutogeneratedFields(), column.Name) {
			continue
		}
		columns = append(columns, toPostgresColumn(column))
	}

	return columns
}

func isIdGenerated(table *core.SQLTable) bool {
	for _, column := range getIdsFields(table) {
		if column.HasDefault {
			return true
		}
	}
	return false
}

func getIdsFields(table *core.SQLTable) []*PostgresColumn {
	columns := []*PostgresColumn{}

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *core.SQLColumn) int {
		return i.Order - j.Order
	})

	ids := getPrimaryFields(table)
	for _, column := range cols {
		if !slices.Contains(ids, column.Name) {
			continue
		}
		columns = append(columns, toPostgresColumn(column))
	}

	return columns
}

func getPrimaryFields(table *core.SQLTable) []string {
	for _, constraint := range table.Constraints {
		if constraint.Type == "PRIMARY" {
			return constraint.Columns
		}
	}

	if len(table.References) > 0 {
		ids := []string{}
		for _, ref := range table.References {
			ids = append(ids, ref.Columns...)
		}
		return ids
	}

	if len(table.Indexes) > 0 {
		return table.Indexes[0].Columns
	}

	return []string{}
}

func getAutogeneratedFields() []string {
	return []string{"created_at", "updated_at", "deleted_at"}
}

func (table *PostgresTable) HasInsertExtraCreated() bool {
	for _, t := range table.Columns {
		if t.NameJson == "created_at" && !t.HasDefault {
			return true
		}
	}

	return false
}

func (table *PostgresTable) HasInsertExtraUpdated() bool {
	for _, t := range table.Columns {
		if t.NameJson == "updated_at" && !t.HasDefault {
			return true
		}
	}

	return false
}

func (table *PostgresTable) HasUpdateExtraUpdated() bool {
	for _, t := range table.Columns {
		if t.NameJson == "updated_at" {
			return true
		}
	}

	return false
}

func (table *PostgresTable) GetTableName() string {
	return fmt.Sprintf("%sTable", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetCreateSqlName() string {
	return fmt.Sprintf("%sCreateSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetCreateSqlContent() string {
	fields := []string{}
	keys := []string{}
	values := []string{}

	for _, val := range table.Columns {
		fields = append(fields, val.Name)
	}

	columns := table.ColumnsUpdate
	if table.HasIdAutoGenerated {
		columns = table.ColumnsCreate
	}

	for id, val := range columns {
		keys = append(keys, val.Name)
		values = append(values, fmt.Sprintf("$%d", id+1))
	}

	if table.HasInsertExtraCreated() {
		keys = append(keys, "created_at")
		values = append(values, "NOW()")
	}

	if table.HasInsertExtraUpdated() {
		keys = append(keys, "updated_at")
		values = append(values, "NOW()")
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) VALUES (%s) RETURNING %s`, table.Name, strings.Join(keys, ", "), strings.Join(values, ", "), strings.Join(fields, ", "))
}

func (table *PostgresTable) GetCreateManySqlName() string {
	return fmt.Sprintf("%sCreateManySql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetCreateManySqlContent() string {
	keys := []string{}
	types := []string{}
	ids := []string{}
	values := []string{"*"}

	for _, val := range table.ColumnsUpdate {
		keys = append(keys, val.Name)
		types = append(types, fmt.Sprintf("%s %s", val.Name, val.TypeSql))
		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, fmt.Sprintf("%s.%s", table.Name, val.Name))
		}
	}

	if table.HasInsertExtraCreated() {
		keys = append(keys, "created_at")
		values = append(values, "NOW()")
	}

	if table.HasInsertExtraUpdated() {
		keys = append(keys, "updated_at")
		values = append(values, "NOW()")
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) SELECT %s FROM jsonb_to_recordset($1) as t(%s) RETURNING %s`,
		table.Name,
		strings.Join(keys, ", "),
		strings.Join(values, ", "),
		strings.Join(types, ", "),
		strings.Join(ids, ", "),
	)
}

func (table *PostgresTable) GetUpsertSqlName() string {
	return fmt.Sprintf("%sUpsertSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpsertSqlContent() string {
	fields := []string{}
	keys := []string{}
	values := []string{}
	ids := []string{}
	set := []string{}

	for _, val := range table.Columns {
		fields = append(fields, val.Name)
	}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, val.Name)
		} else {
			set = append(set, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("EXCLUDED.%s", val.Name)))
		}

		keys = append(keys, val.Name)
		values = append(values, fmt.Sprintf("$%d", id+1))
	}

	if table.HasInsertExtraCreated() {
		keys = append(keys, "created_at")
		values = append(values, "NOW()")
	}

	if table.HasInsertExtraUpdated() {
		keys = append(keys, "updated_at")
		values = append(values, "NOW()")
	}

	if table.HasUpdateExtraUpdated() {
		set = append(set, "updated_at=NOW()")
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) VALUES (%s) ON CONFLICT(%s) DO UPDATE SET %s RETURNING %s`,
		table.Name,
		strings.Join(keys, ", "),
		strings.Join(values, ", "),
		strings.Join(ids, ", "),
		strings.Join(set, ", "),
		strings.Join(fields, ", "),
	)
}

func (table *PostgresTable) GetUpsertManySqlName() string {
	return fmt.Sprintf("%sUpsertManySql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpsertManySqlContent() string {
	keys := []string{}
	values := []string{"*"}
	types := []string{}
	ids := []string{}
	returning := []string{}
	set := []string{}

	for _, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, val.Name)
			returning = append(returning, fmt.Sprintf("%s.%s", table.Name, val.Name))
		} else {
			set = append(set, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("EXCLUDED.%s", val.Name)))
		}
		keys = append(keys, val.Name)
		types = append(types, fmt.Sprintf("%s %s", val.Name, val.TypeSql))
	}

	if table.HasInsertExtraCreated() {
		keys = append(keys, "created_at")
		values = append(values, "NOW()")
	}

	if table.HasInsertExtraUpdated() {
		keys = append(keys, "updated_at")
		values = append(values, "NOW()")
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) SELECT %s FROM jsonb_to_recordset($1) as t(%s) ON CONFLICT(%s) DO UPDATE SET %s RETURNING %s`,
		table.Name,
		strings.Join(keys, ", "),
		strings.Join(values, ", "),
		strings.Join(types, ", "),
		strings.Join(ids, ", "),
		strings.Join(set, ", "),
		strings.Join(returning, ", "),
	)
}

func (table *PostgresTable) GetUpdateSqlName() string {
	return fmt.Sprintf("%sUpdateSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpdateSqlContent() string {
	fields := []string{}
	keys := []string{}
	values := []string{}

	for _, val := range table.Columns {
		fields = append(fields, val.Name)
	}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			keys = append(keys, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		} else {
			values = append(values, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		}
	}

	if table.HasUpdateExtraUpdated() {
		values = append(values, "updated_at=NOW()")
	}

	return fmt.Sprintf(`UPDATE %s SET %s WHERE %s RETURNING %s`, table.Name, strings.Join(values, ", "), strings.Join(keys, " AND "), strings.Join(fields, ", "))
}

func (table *PostgresTable) GetUpdateManySqlName() string {
	return fmt.Sprintf("%sUpdateManySql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpdateManySqlContent() string {
	ids := []string{}
	set := []string{}
	types := []string{}
	where := []string{}

	for _, val := range table.ColumnsUpdate {
		types = append(types, fmt.Sprintf("%s %s", val.Name, val.TypeSql))

		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, fmt.Sprintf("%s.%s", table.Name, val.Name))
			where = append(where, fmt.Sprintf("%s.%s=t.%s", table.Name, val.Name, val.Name))
		} else {
			set = append(set, fmt.Sprintf("%s=t.%s", val.Name, val.Name))
		}
	}

	return fmt.Sprintf(`UPDATE %s SET %s FROM jsonb_to_recordset($1) as t(%s) WHERE %s RETURNING %s`,
		table.Name,
		strings.Join(set, ", "),
		strings.Join(types, ", "),
		strings.Join(where, " AND "),
		strings.Join(ids, ", "),
	)
}

func (table *PostgresTable) GetDeleteSoftSqlName() string {
	fields := []string{}
	for _, column := range table.Columns {
		fields = append(fields, column.Name)
	}

	if !slices.Contains(fields, "deleted_at") {
		return ""
	}

	return fmt.Sprintf("%sDeleteSoftSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetDeleteSoftSqlContent() string {
	keys := []string{}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			keys = append(keys, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		}
	}

	return fmt.Sprintf(`UPDATE %s SET deleted_at=NOW() WHERE %s`, table.Name, strings.Join(keys, " AND "))
}

func (table *PostgresTable) GetDeleteHardSqlName() string {
	return fmt.Sprintf("%sDeleteHardSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetDeleteHardSqlContent() string {
	keys := []string{}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			keys = append(keys, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		}
	}

	return fmt.Sprintf(`DELETE FROM %s WHERE %s`, table.Name, strings.Join(keys, " AND "))
}

func (table *PostgresTable) GetPrimaryInit() []string {
	fields := []string{}

	for _, c := range table.Columns {
		if !slices.Contains(table.Primary, c.Name) {
			continue
		}

		if c.HasDefault {
			continue
		}

		if strings.Contains(c.Type, "uuid") {
			fields = append(fields, "uuid.New()")
		} else {
			fields = append(fields, fmt.Sprintf("input.%s", c.NameNormalized))
		}
	}

	return fields
}

func (table *PostgresTable) GetSelectPrimarySql() []SelectQuery {
	entries := []SelectQuery{}

	entries = append(entries, SelectQuery{
		Name:   table.NameNormalized,
		Method: "FindById",
		Fields: table.ColumnIds,
	})

	return entries
}

func (table *PostgresTable) GetSelectSql() []SelectQueryRef {
	entries := []SelectQueryRef{}

	for _, ref := range table.table.References {
		refFields := []*PostgresColumn{}
		for _, column := range table.Columns {
			if !slices.Contains(ref.Columns, column.Name) {
				continue
			}
			refFields = append(refFields, column)
		}

		entries = append(entries, SelectQueryRef{
			FromTable:  table.NameNormalized,
			ToTable:    strcase.ToCamel(plural.Singular(ref.Table)),
			Ref:        strcase.ToCamel(plural.Singular(ref.Table)),
			GetMethod:  fmt.Sprintf("GetBy%s", strcase.ToCamel(strings.Join(ref.Columns, "_"))),
			FromAccess: strcase.ToCamel(plural.Plural(table.Name)),
			Fields:     refFields,
		})
	}

	return entries
}
