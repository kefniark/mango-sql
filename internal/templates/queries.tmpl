// Insert a {{ .NameNormalized }} and return the created row
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.Insert({{ .NameNormalized }}Create{
//     // ...
//   })
//
// SQL Statement:
//   {{ .GetCreateSqlContent }}
func (q *{{ .NameNormalized }}Queries) Insert(input {{ .NameNormalized }}Create) (*{{ .NameNormalized }}Model, error) {
	data := &{{ .NameNormalized }}Model{}
	if err := q.ctx.queryOne(data, {{ .GetCreateSqlName }}, uuid.New(), {{ range .ColumnsCreate }}input.{{ .NameNormalized }}, {{ end }}); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Insert {{ .NameNormalized }}
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.InsertMany([]{{ .NameNormalized }}Create{
//     // ...
//   })
//
// SQL Statement:
//   {{ .GetCreateManySqlContent }}
func (q *{{ .NameNormalized }}Queries) InsertMany(inputs []{{ .NameNormalized }}Create) ([]{{ .NameNormalized }}PrimaryKey, error) {
	ids := []{{ .NameNormalized }}PrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		records := make([]{{ .NameNormalized }}Update, len(chunk))
		for i, input := range chunk {
			records[i] = {{ if not .HasCompositeId }}{{ .NameNormalized }}Update{
				Id:    uuid.New(),
				{{ range .ColumnsCreate }}          {{ .NameNormalized }}: input.{{ .NameNormalized }},
				{{ end }}
			}{{ else }}{{ .NameNormalized }}Update(input){{ end }}
		}

		data, err := json.Marshal(records)
		if err != nil {
			return nil, err
		}

		loopIds := []{{ .NameNormalized }}PrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, {{ .GetCreateManySqlName }}, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Upsert a {{ .NameNormalized }} (create or update if already exist) and return the updated row
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.Upsert({{ .NameNormalized }}Update{
//     // ...
//   })
//
// SQL Statement:
//   {{ .GetUpsertSqlContent }}
func (q *{{ .NameNormalized }}Queries) Upsert(input {{ .NameNormalized }}Update) (*{{ .NameNormalized }}Model, error) {
	data := &{{ .NameNormalized }}Model{}
	if err := q.ctx.queryOne(data, {{ .GetUpsertSqlName }}, {{ range .ColumnsUpdate }}input.{{ .NameNormalized }}, {{ end }}); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Upsert {{ .NameNormalized }} (create or update if already exist)
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.UpsertMany([]{{ .NameNormalized }}Update{
//     // ...
//   })
//
// SQL Statement:
//   {{ .GetUpsertManySqlContent }}
func (q *{{ .NameNormalized }}Queries) UpsertMany(inputs []{{ .NameNormalized }}Update) ([]{{ .NameNormalized }}PrimaryKey, error) {
	ids := []{{ .NameNormalized }}PrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []{{ .NameNormalized }}PrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, {{ .GetUpsertManySqlName }}, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Update a {{ .NameNormalized }} and return the updated row
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.Update({{ .NameNormalized }}Update{
//     // ...
//   })
//
// SQL Statement:
//   {{ .GetUpdateSqlContent }}
func (q *{{ .NameNormalized }}Queries) Update(input {{ .NameNormalized }}Update) (*{{ .NameNormalized }}Model, error) {
	data := &{{ .NameNormalized }}Model{}
	if err := q.ctx.queryOne(data, {{ .GetUpdateSqlName }}, {{ range .ColumnsUpdate }}input.{{ .NameNormalized }}, {{ end }}); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Update {{ .NameNormalized }}
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.UpdateMany([]{{ .NameNormalized }}Update{
//     // ...
//   })
//
// SQL Statement:
//   {{ .GetUpdateManySqlContent }}
func (q *{{ .NameNormalized }}Queries) UpdateMany(inputs []{{ .NameNormalized }}Update) ([]{{ .NameNormalized }}PrimaryKey, error) {
	ids := []{{ .NameNormalized }}PrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []{{ .NameNormalized }}PrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, {{ .GetUpdateManySqlName }}, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

{{ if .GetDeleteSoftSqlName }}// Delete a {{ .NameNormalized }} (soft delete, data are still in the database)
//
// Usage:
//   err := db.{{ .NameNormalized }}.DeleteSoft(id)
//
// SQL Statement:
//   {{ .GetDeleteSoftSqlContent }}
func (q *{{ .NameNormalized }}Queries) DeleteSoft(id {{ .NameNormalized }}PrimaryKey) error {
	return q.ctx.exec({{ .GetDeleteSoftSqlName }}, id)
}

// Delete a {{ .NameNormalized }} (soft delete, data are still in the database)
func (q *{{ .NameNormalized }}Model) DeleteSoft(db *DBClient) error {
   {{ if .HasCompositeId }}return db.{{ .NameNormalized }}.DeleteSoft({{ .NameNormalized }}PrimaryKey{
		{{ range .ColumnIds }}    {{ .NameNormalized }}: q.{{ .NameNormalized }},
		{{ end }}
	}){{ else }}return db.{{ .NameNormalized }}.DeleteSoft(q.Id){{ end }}
}{{end}}

// Delete a {{ .NameNormalized }} (hard delete, data are removed from the database)
//
// Usage:
//   err := db.{{ .NameNormalized }}.DeleteHard(id)
//
// SQL Statement:
//   {{ .GetDeleteHardSqlContent }}
func (q *{{ .NameNormalized }}Queries) DeleteHard(id {{ .NameNormalized }}PrimaryKey) error {
	return q.ctx.exec({{ .GetDeleteHardSqlName }}, id)
}

// Delete a {{ .NameNormalized }} (hard delete, data are removed from the database)
func (q *{{ .NameNormalized }}Model) DeleteHard(db *DBClient) error {
	{{ if .HasCompositeId }}return db.{{ .NameNormalized }}.DeleteHard({{ .NameNormalized }}PrimaryKey{
		{{ range .ColumnIds }}    {{ .NameNormalized }}: q.{{ .NameNormalized }},
		{{ end }}
	}){{ else }}return db.{{ .NameNormalized }}.DeleteHard(q.Id){{ end }}
}

// Count {{ .NameNormalized }} records based on filter conditions
//
// Usage:
//   count, err := db.{{ .NameNormalized }}.Count(
//     // ... can use filters here (cf db.{{ .NameNormalized }}.Query.*)
//   )
func (q *{{ .NameNormalized }}Queries) Count(filters ...WhereCondition) (int, error) {
	query := squirrel.Select("count(id)").From({{ .GetTableName }}).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = q.ctx.queryOne(&count, sql, args...)
	return count, err
}

// Find {{ .NameNormalized }} records based on the provided conditions
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.FindMany(
//     // ... can use filters here (cf db.{{ .NameNormalized }}.Query.*)
//   )
func (q *{{ .NameNormalized }}Queries) FindMany(filters ...WhereCondition) ([]{{ .NameNormalized }}Model, error) {
	query := squirrel.Select({{ .NameNormalized }}Fields...).From({{ .GetTableName }}).PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []{{ .NameNormalized }}Model{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

// Find one {{ .NameNormalized }} records based on the provided conditions
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.FindUnique(
//     // ... can use filters here (cf db.{{ .NameNormalized }}.Query.*)
//   )
func (q *{{ .NameNormalized }}Queries) FindUnique(filters ...WhereCondition) (*{{ .NameNormalized }}Model, error) {
	filters = append(filters, limitFirst)
	return first(q.FindMany(filters...))
}

{{ range .GetSelectPrimarySql }}
// Find {{ .Name }} By PrimaryKey
//
// Usage:
//   entity, err := db.{{ .Name }}.{{ .Method }}(id)
func (q *{{ .Name }}Queries) {{ .Method }}(id {{ .Name }}PrimaryKey) (*{{ .Name }}Model, error) {
	return q.FindUnique(func(cond SelectBuilder) SelectBuilder {
		{{ if $.HasCompositeId }}return cond{{ range .Fields }}.Where("{{ .Name }} = $1", id.{{ .NameNormalized }}){{ end }}
		{{ else }}return cond{{ range .Fields }}.Where("{{ .Name }} = $1", id){{ end }}{{ end }}
	})
}

{{ if not $.HasCompositeId }}// Batch Find {{ .Name }} By PrimaryKey
//
// Usage:
//   entities, err := db.{{ .Name }}.{{ .Method }}s(ids)
func (q *{{ .Name }}Queries) {{ .Method }}s(ids ...{{ .Name }}PrimaryKey) ([]{{ .Name }}Model, error) {
	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
		return cond{{ range .Fields }}.Where("{{ .Name }} = ANY($1)", pq.Array(ids)){{ end }}
	})
}
{{ end }}{{ end }}

{{ range .GetFilters }}
// {{ .Comment }}
func ({{ .Model }}Filters) {{ .Name }}({{ range .Args }}{{ . }},{{ end}}) WhereCondition {
	return func(cond SelectBuilder) SelectBuilder {
		return cond{{ .Sql }}
	}
}
{{ end }}