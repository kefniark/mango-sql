// Insert a {{ .NameNormalized }} and return the created row
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.Insert({{ .NameNormalized }}Create{
//     // ...
//   })
func (q *{{ .NameNormalized }}Queries) Insert(input {{ .NameNormalized }}Create) (*{{ .NameNormalized }}Model, error) {
	sql := `{{ .GetCreateSqlContent }}`
	data := &{{ .NameNormalized }}Model{}
	// 
	if err := q.ctx.queryOne(data, sql, {{ range .GetPrimaryInit }} {{ . }}, {{ end }} {{ range .ColumnsCreate }}{{ if .IsArray }}pq.Array(input.{{ .NameNormalized }}), {{ else }}input.{{ .NameNormalized }}, {{ end }}{{ end }}); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Insert {{ .NameNormalized }}
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.InsertMany([]{{ .NameNormalized }}Create{
//     // ...
//   })
func (q *{{ .NameNormalized }}Queries) InsertMany(inputs []{{ .NameNormalized }}Create) ([]{{ .NameNormalized }}PrimaryKey, error) {
	sql := `{{ .GetCreateManySqlContent }}`
	ids := []{{ .NameNormalized }}PrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		records := make([]{{ .NameNormalized }}Update, len(chunk))
		for i, input := range chunk {
			records[i] = {{ if not .HasCompositeId }}{{ .NameNormalized }}Update{
				{{ if not .HasIdAutoGenerated }} Id:    uuid.New(),{{end}}
				{{ range .ColumnsCreate }}          {{ .NameNormalized }}: input.{{ .NameNormalized }},
				{{ end }}
			}{{ else }}{{ .NameNormalized }}Update(input){{ end }}
		}

		data, err := json.Marshal(records)
		if err != nil {
			return nil, err
		}

		loopIds := []{{ .NameNormalized }}PrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, sql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Upsert a {{ .NameNormalized }} (create or update if already exist) and return the updated row
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.Upsert({{ .NameNormalized }}Update{
//     // ...
//   })
func (q *{{ .NameNormalized }}Queries) Upsert(input {{ .NameNormalized }}Update) (*{{ .NameNormalized }}Model, error) {
	sql := `{{ .GetUpsertSqlContent }}`
	data := &{{ .NameNormalized }}Model{}
	if err := q.ctx.queryOne(data, sql, {{ range .ColumnsUpdate }}input.{{ .NameNormalized }}, {{ end }}); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Upsert {{ .NameNormalized }} (create or update if already exist)
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.UpsertMany([]{{ .NameNormalized }}Update{
//     // ...
//   })
func (q *{{ .NameNormalized }}Queries) UpsertMany(inputs []{{ .NameNormalized }}Update) ([]{{ .NameNormalized }}PrimaryKey, error) {
	sql := `{{ .GetUpsertManySqlContent }}`
	ids := []{{ .NameNormalized }}PrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []{{ .NameNormalized }}PrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, sql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

// Update a {{ .NameNormalized }} and return the updated row
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.Update({{ .NameNormalized }}Update{
//     // ...
//   })
func (q *{{ .NameNormalized }}Queries) Update(input {{ .NameNormalized }}Update) (*{{ .NameNormalized }}Model, error) {
	sql := `{{ .GetUpdateSqlContent }}`
	data := &{{ .NameNormalized }}Model{}
	if err := q.ctx.queryOne(data, sql, {{ range .ColumnsUpdate }}input.{{ .NameNormalized }}, {{ end }}); err != nil {
		return nil, err
	}
	return data, nil
}

// Batch Update {{ .NameNormalized }}
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.UpdateMany([]{{ .NameNormalized }}Update{
//     // ...
//   })
func (q *{{ .NameNormalized }}Queries) UpdateMany(inputs []{{ .NameNormalized }}Update) ([]{{ .NameNormalized }}PrimaryKey, error) {
	sql := `{{ .GetUpdateManySqlContent }}`
	ids := []{{ .NameNormalized }}PrimaryKey{}
	for _, chunk := range chunkBy(inputs, 250) {
		data, err := json.Marshal(chunk)
		if err != nil {
			return nil, err
		}

		loopIds := []{{ .NameNormalized }}PrimaryKey{}
		if err = q.ctx.queryMany(&loopIds, sql, data); err != nil {
			return nil, err
		}
		ids = append(ids, loopIds...)
	}

	return ids, nil
}

{{ if .GetDeleteSoftSqlName }}// Delete a {{ .NameNormalized }} (soft delete, data are still in the database)
//
// Usage:
//   err := db.{{ .NameNormalized }}.DeleteSoft(id)
func (q *{{ .NameNormalized }}Queries) DeleteSoft(id {{ .NameNormalized }}PrimaryKey) error {
	return q.ctx.exec(`{{ .GetDeleteSoftSqlContent }}`, id)
}

// Delete a {{ .NameNormalized }} (soft delete, data are still in the database)
func (q *{{ .NameNormalized }}Model) DeleteSoft(db *DBClient) error {
   {{ if .HasCompositeId }}return db.{{ .NameNormalized }}.DeleteSoft({{ .NameNormalized }}PrimaryKey{
		{{ range .ColumnIds }}    {{ .NameNormalized }}: q.{{ .NameNormalized }},
		{{ end }}
	}){{ else }}return db.{{ .NameNormalized }}.DeleteSoft(q.Id){{ end }}
}{{end}}

// Delete a {{ .NameNormalized }} (hard delete, data are removed from the database)
//
// Usage:
//   err := db.{{ .NameNormalized }}.DeleteHard(id)
func (q *{{ .NameNormalized }}Queries) DeleteHard(id {{ .NameNormalized }}PrimaryKey) error {
	return q.ctx.exec(`{{ .GetDeleteHardSqlContent }}`, id)
}

// Delete a {{ .NameNormalized }} (hard delete, data are removed from the database)
func (q *{{ .NameNormalized }}Model) DeleteHard(db *DBClient) error {
	{{ if .HasCompositeId }}return db.{{ .NameNormalized }}.DeleteHard({{ .NameNormalized }}PrimaryKey{
		{{ range .ColumnIds }}    {{ .NameNormalized }}: q.{{ .NameNormalized }},
		{{ end }}
	}){{ else }}return db.{{ .NameNormalized }}.DeleteHard(q.Id){{ end }}
}

// Count {{ .NameNormalized }} records based on filter conditions
//
// Usage:
//   count, err := db.{{ .NameNormalized }}.Count(
//     // ... can use filters here (cf db.{{ .NameNormalized }}.Query.*)
//   )
func (q *{{ .NameNormalized }}Queries) Count(filters ...WhereCondition) (int, error) {
	query := squirrel.Select("count(id)").From("{{ .Name }}").PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return 0, err
	}

	count := 0
	err = q.ctx.queryOne(&count, sql, args...)
	return count, err
}

// Find {{ .NameNormalized }} records based on the provided conditions
//
// Usage:
//   entities, err := db.{{ .NameNormalized }}.FindMany(
//     // ... can use filters here (cf db.{{ .NameNormalized }}.Query.*)
//   )
func (q *{{ .NameNormalized }}Queries) FindMany(filters ...WhereCondition) ([]{{ .NameNormalized }}Model, error) {
	query := squirrel.Select({{ .NameNormalized }}Fields...).From("{{ .Name }}").PlaceholderFormat(squirrel.Dollar)
	for _, filter := range filters {
		query = filter(query)
	}

	sql, args, err := query.ToSql()
	if err != nil {
		return nil, err
	}

	entries := []{{ .NameNormalized }}Model{}
	err = q.ctx.queryMany(&entries, sql, args...)
	return entries, err
}

// Find one {{ .NameNormalized }} records based on the provided conditions
//
// Usage:
//   entity, err := db.{{ .NameNormalized }}.FindUnique(
//     // ... can use filters here (cf db.{{ .NameNormalized }}.Query.*)
//   )
func (q *{{ .NameNormalized }}Queries) FindUnique(filters ...WhereCondition) (*{{ .NameNormalized }}Model, error) {
	filters = append(filters, limitFirst)
	return first(q.FindMany(filters...))
}

{{ range .GetSelectPrimarySql }}
// Find {{ .Name }} By PrimaryKey
//
// Usage:
//   entity, err := db.{{ .Name }}.{{ .Method }}(id)
func (q *{{ .Name }}Queries) {{ .Method }}(id {{ .Name }}PrimaryKey) (*{{ .Name }}Model, error) {
	return q.FindUnique(func(cond SelectBuilder) SelectBuilder {
		{{ if $.HasCompositeId }}return cond{{ range $i, $f := .Fields }}.Where("{{ $f.Name }} = ${{ len (printf "a%*s" $i "") }}", id.{{ $f.NameNormalized }}){{ end }}
		{{ else }}return cond{{ range .Fields }}.Where("{{ .Name }} = $1", id){{ end }}{{ end }}
	})
}

{{ if not $.HasCompositeId }}// Batch Find {{ .Name }} By PrimaryKey
//
// Usage:
//   entities, err := db.{{ .Name }}.{{ .Method }}s(ids)
func (q *{{ .Name }}Queries) {{ .Method }}s(ids ...{{ .Name }}PrimaryKey) ([]{{ .Name }}Model, error) {
	return q.FindMany(func(cond SelectBuilder) SelectBuilder {
		return cond{{ range .Fields }}.Where("{{ .Name }} = ANY($1)", pq.Array(ids)){{ end }}
	})
}
{{ end }}{{ end }}
