package internal

import (
	"bufio"
	"bytes"
	"embed"
	"fmt"
	"io"
	"slices"
	"strings"
	"text/template"
	"time"

	"github.com/gertd/go-pluralize"
	"github.com/iancoleman/strcase"
	"golang.org/x/exp/maps"
)

//go:embed templates/*.tmpl
var templates embed.FS

var plural = pluralize.NewClient()

func Generate(schema *SQLSchema, contents io.Writer, pkg string) error {
	headerTmpl, err := template.ParseFS(templates, "templates/header.tmpl")
	if err != nil {
		return err
	}

	factoryTmpl, err := template.ParseFS(templates, "templates/factory.tmpl")
	if err != nil {
		return err
	}

	ctxConstTmpl, err := template.ParseFS(templates, "templates/ctx_const.tmpl")
	if err != nil {
		return err
	}

	ctxTmpl, err := template.ParseFS(templates, "templates/ctx.tmpl")
	if err != nil {
		return err
	}

	modelTmpl, err := template.ParseFS(templates, "templates/model.tmpl")
	if err != nil {
		return err
	}

	queriesTmpl, err := template.ParseFS(templates, "templates/queries.tmpl")
	if err != nil {
		return err
	}

	tables := maps.Values(schema.Tables)
	slices.SortFunc(tables, func(i, j *SQLTable) int {
		return i.Order - j.Order
	})

	postgresTables := []*PostgresTable{}
	for _, table := range tables {
		entry := toPostgresTable(table)
		entry.schema = schema
		entry.table = table
		postgresTables = append(postgresTables, entry)
	}

	var ctxConstBuf bytes.Buffer
	ctxConst := bufio.NewWriter(&ctxConstBuf)

	for _, table := range postgresTables {
		if err = ctxConstTmpl.Execute(ctxConst, table); err != nil {
			return err
		}
	}
	ctxConst.Flush()

	if err = headerTmpl.Execute(contents, HeaderData{
		Package: pkg,
		Url:     "https://github.com/kefniark/mangosql",
		Date:    time.Now().String(),
		Version: "0.0.1",
	}); err != nil {
		return err
	}

	if err = factoryTmpl.Execute(contents, postgresTables); err != nil {
		return err
	}

	if err = ctxTmpl.Execute(contents, PostgresCtx{
		Const: ctxConstBuf.String(),
	}); err != nil {
		return err
	}

	for _, table := range postgresTables {
		if err = modelTmpl.Execute(contents, table); err != nil {
			return err
		}

		if err = queriesTmpl.Execute(contents, table); err != nil {
			return err
		}
	}

	return nil
}

type PostgresCtx struct {
	Const string
}

type PostgresTable struct {
	schema *SQLSchema
	table  *SQLTable

	Name           string
	NameNormalized string
	HasCompositeId bool
	ColumnIds      []*PostgresColumn
	Columns        []*PostgresColumn
	ColumnsCreate  []*PostgresColumn
	ColumnsUpdate  []*PostgresColumn
	Primary        []string
}

type PostgresColumn struct {
	Name           string
	NameNormalized string
	Type           string
	TypeSql        string
	Nullable       bool
}

func toPostgresTable(table *SQLTable) *PostgresTable {
	columns := []*PostgresColumn{}

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *SQLColumn) int {
		return i.Order - j.Order
	})

	for _, column := range cols {
		if col := toPostgresColumn(column); col != nil {
			columns = append(columns, col)
		}
	}

	return &PostgresTable{
		Name:           table.Name,
		NameNormalized: strcase.ToCamel(plural.Singular(table.Name)),
		Columns:        columns,
		HasCompositeId: len(getPrimaryFields(table)) > 1,
		ColumnIds:      getIdsFields(table),
		ColumnsCreate:  getCreateFields(table),
		ColumnsUpdate:  getUpdateFields(table),
		Primary:        getPrimaryFields(table),
	}
}

func toPostgresColumn(column *SQLColumn) *PostgresColumn {
	var val string
	if column.Nullable {
		t, ok := postgresNullableType[column.Type]
		if !ok {
			fmt.Println("Unknown type", column.Type)
			return nil
		}
		val = t
	} else {
		t, ok := postgresType[column.Type]
		if !ok {
			fmt.Println("Unknown type", column.Type)
			return nil
		}
		val = t
	}

	return &PostgresColumn{
		Name:           column.Name,
		NameNormalized: strcase.ToCamel(plural.Singular(column.Name)),
		Type:           val,
		TypeSql:        column.TypeSql,
		Nullable:       column.Nullable,
	}
}

func getCreateFields(table *SQLTable) []*PostgresColumn {
	columns := []*PostgresColumn{}
	primary := getPrimaryFields(table)

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *SQLColumn) int {
		return i.Order - j.Order
	})

	for _, column := range cols {
		if slices.Contains(primary, column.Name) {
			continue
		}
		if slices.Contains(getAutogeneratedFields(), column.Name) {
			continue
		}
		columns = append(columns, toPostgresColumn(column))
	}

	return columns
}

func getUpdateFields(table *SQLTable) []*PostgresColumn {
	columns := []*PostgresColumn{}

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *SQLColumn) int {
		return i.Order - j.Order
	})

	for _, column := range cols {
		if slices.Contains(getAutogeneratedFields(), column.Name) {
			continue
		}
		columns = append(columns, toPostgresColumn(column))
	}

	return columns
}

func getIdsFields(table *SQLTable) []*PostgresColumn {
	columns := []*PostgresColumn{}

	cols := maps.Values(table.Columns)
	slices.SortFunc(cols, func(i, j *SQLColumn) int {
		return i.Order - j.Order
	})

	ids := getPrimaryFields(table)
	for _, column := range cols {
		if !slices.Contains(ids, column.Name) {
			continue
		}
		columns = append(columns, toPostgresColumn(column))
	}

	return columns
}

func getPrimaryFields(table *SQLTable) []string {
	for _, constraint := range table.Constraints {
		if constraint.Type == "PRIMARY" {
			return constraint.Columns
		}
	}

	return []string{}
}

func getAutogeneratedFields() []string {
	return []string{"created_at", "updated_at", "deleted_at"}
}

var postgresNullableType = map[string]string{
	"int":       "sql.NullInt64",
	"integer":   "sql.NullInt64",
	"float":     "sql.NullFloat64",
	"string":    "sql.NullString",
	"text":      "sql.NullString",
	"varchar":   "sql.NullString",
	"timestamp": "sql.NullTime",
	"uuid":      "*uuid.UUID",
}
var postgresType = map[string]string{
	"int":       "int64",
	"integer":   "int64",
	"float":     "float64",
	"string":    "string",
	"text":      "string",
	"varchar":   "string",
	"timestamp": "time.Time",
	"uuid":      "uuid.UUID",
}

func (table *PostgresTable) GetTableName() string {
	return fmt.Sprintf("%sTable", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetCreateSqlName() string {
	return fmt.Sprintf("%sCreateSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetCreateSqlContent() string {
	fields := []string{}
	keys := []string{}
	values := []string{}

	for _, val := range table.Columns {
		fields = append(fields, val.Name)
	}

	for id, val := range table.ColumnsUpdate {
		keys = append(keys, val.Name)
		values = append(values, fmt.Sprintf("$%d", id+1))
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) VALUES (%s) RETURNING %s`, table.Name, strings.Join(keys, ", "), strings.Join(values, ", "), strings.Join(fields, ", "))
}

func (table *PostgresTable) GetCreateManySqlName() string {
	return fmt.Sprintf("%sCreateManySql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetCreateManySqlContent() string {
	keys := []string{}
	types := []string{}
	ids := []string{}

	for _, val := range table.ColumnsUpdate {
		keys = append(keys, val.Name)
		types = append(types, fmt.Sprintf("%s %s", val.Name, val.TypeSql))
		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, fmt.Sprintf("%s.%s", table.Name, val.Name))
		}
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) SELECT * FROM jsonb_to_recordset($1) as t(%s) RETURNING %s`,
		table.Name,
		strings.Join(keys, ", "),
		strings.Join(types, ", "),
		strings.Join(ids, ", "),
	)
}

func (table *PostgresTable) GetUpsertSqlName() string {
	return fmt.Sprintf("%sUpsertSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpsertSqlContent() string {
	fields := []string{}
	keys := []string{}
	values := []string{}
	ids := []string{}
	set := []string{}

	for _, val := range table.Columns {
		fields = append(fields, val.Name)
	}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, val.Name)
		} else {
			set = append(set, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("EXCLUDED.%s", val.Name)))
		}

		keys = append(keys, val.Name)
		values = append(values, fmt.Sprintf("$%d", id+1))
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) VALUES (%s) ON CONFLICT(%s) DO UPDATE SET %s RETURNING %s`,
		table.Name,
		strings.Join(keys, ", "),
		strings.Join(values, ", "),
		strings.Join(ids, ", "),
		strings.Join(set, ", "),
		strings.Join(fields, ", "),
	)
}

func (table *PostgresTable) GetUpsertManySqlName() string {
	return fmt.Sprintf("%sUpsertManySql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpsertManySqlContent() string {
	keys := []string{}
	types := []string{}
	ids := []string{}
	returning := []string{}
	set := []string{}

	for _, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, val.Name)
			returning = append(returning, fmt.Sprintf("%s.%s", table.Name, val.Name))
		} else {
			set = append(set, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("EXCLUDED.%s", val.Name)))
		}
		keys = append(keys, val.Name)
		types = append(types, fmt.Sprintf("%s %s", val.Name, val.TypeSql))
	}

	return fmt.Sprintf(`INSERT INTO %s (%s) SELECT * FROM jsonb_to_recordset($1) as t(%s) ON CONFLICT(%s) DO UPDATE SET %s RETURNING %s`,
		table.Name,
		strings.Join(keys, ", "),
		strings.Join(types, ", "),
		strings.Join(ids, ", "),
		strings.Join(set, ", "),
		strings.Join(returning, ", "),
	)
}

func (table *PostgresTable) GetUpdateSqlName() string {
	return fmt.Sprintf("%sUpdateSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpdateSqlContent() string {
	fields := []string{}
	keys := []string{}
	values := []string{}

	for _, val := range table.Columns {
		fields = append(fields, val.Name)
	}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			keys = append(keys, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		} else {
			values = append(values, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		}
	}

	return fmt.Sprintf(`UPDATE %s SET %s WHERE %s RETURNING %s`, table.Name, strings.Join(values, ", "), strings.Join(keys, ", "), strings.Join(fields, ", "))
}

func (table *PostgresTable) GetUpdateManySqlName() string {
	return fmt.Sprintf("%sUpdateManySql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetUpdateManySqlContent() string {
	ids := []string{}
	set := []string{}
	types := []string{}
	where := []string{}

	for _, val := range table.ColumnsUpdate {
		types = append(types, fmt.Sprintf("%s %s", val.Name, val.TypeSql))

		if slices.Contains(table.Primary, val.Name) {
			ids = append(ids, fmt.Sprintf("%s.%s", table.Name, val.Name))
			where = append(where, fmt.Sprintf("%s.%s=t.%s", table.Name, val.Name, val.Name))
		} else {
			set = append(set, fmt.Sprintf("%s=t.%s", val.Name, val.Name))
		}
	}

	return fmt.Sprintf(`UPDATE %s SET %s FROM jsonb_to_recordset($1) as t(%s) WHERE %s RETURNING %s`,
		table.Name,
		strings.Join(set, ", "),
		strings.Join(types, ", "),
		strings.Join(where, ", "),
		strings.Join(ids, ", "),
	)
}

func (table *PostgresTable) GetDeleteSoftSqlName() string {
	fields := []string{}
	for _, column := range table.Columns {
		fields = append(fields, column.Name)
	}

	if !slices.Contains(fields, "deleted_at") {
		return ""
	}

	return fmt.Sprintf("%sDeleteSoftSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetDeleteSoftSqlContent() string {
	keys := []string{}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			keys = append(keys, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		}
	}

	return fmt.Sprintf(`UPDATE %s SET deleted_at=NOW() WHERE %s`, table.Name, strings.Join(keys, ", "))
}

func (table *PostgresTable) GetDeleteHardSqlName() string {
	return fmt.Sprintf("%sDeleteHardSql", strcase.ToLowerCamel(plural.Singular(table.Name)))
}

func (table *PostgresTable) GetDeleteHardSqlContent() string {
	keys := []string{}

	for id, val := range table.ColumnsUpdate {
		if slices.Contains(table.Primary, val.Name) {
			keys = append(keys, fmt.Sprintf("%s=%s", val.Name, fmt.Sprintf("$%d", id+1)))
		}
	}

	return fmt.Sprintf(`DELETE FROM %s WHERE %s`, table.Name, strings.Join(keys, ", "))
}

func (table *PostgresTable) GetSelectSql() []SelectQuery {
	entries := []SelectQuery{}
	for _, index := range table.table.Constraints {
		if index.Type != "UNIQUE" && index.Type != "PRIMARY" {
			continue
		}
		keys := []string{}
		fields := []string{}
		ids := []string{}
		for id, val := range index.Columns {
			ids = append(ids, val)
			keys = append(keys, fmt.Sprintf("%s=%s", val, fmt.Sprintf("$%d", id+1)))
		}

		for _, column := range table.Columns {
			fields = append(fields, column.Name)
		}

		var_name := strcase.ToLowerCamel(fmt.Sprintf(`%sGetBy%sSql`, strcase.ToCamel(table.NameNormalized), strcase.ToCamel(strings.Join(ids, "_"))))
		method_name := fmt.Sprintf(`GetBy%s`, strcase.ToCamel(strings.Join(ids, "_")))

		entries = append(entries, SelectQuery{
			Name:   table.NameNormalized,
			Var:    var_name,
			Method: method_name,
			Sql:    fmt.Sprintf(`SELECT %s FROM %s WHERE %s LIMIT 1`, strings.Join(fields, ", "), table.Name, strings.Join(keys, ", ")),
		})
	}

	return entries
}

type SelectQuery struct {
	Name   string
	Var    string
	Method string
	Sql    string
}

type HeaderData struct {
	Package string
	Url     string
	Date    string
	Version string
}
